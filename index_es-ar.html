<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<title>
			jQuery vs MooTools: Eligiendo entre dos Excelentes Frameworks de JavaScript
		</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<link rel="Shortcut Icon" href="favicon.ico" type="image/x-icon">
		<link rel="stylesheet" href="css/blueprint/screen.css" type="text/css" media="screen, projection">
		<link rel="stylesheet" href="css/blueprint/print.css" type="text/css" media="print">	
		<!--[if IE]><link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->
		<link rel="stylesheet" href="css/blueprint/src/typography.css" type="text/css" media="screen" title="no title" charset="utf-8">
		<style>
			body { 
			  font-size: 100%;
			  color: #444; 
			  background: #fff;
			  font-family: "Georgia", Arial, Helvetica, sans-serif;
			}
			h1, h2, h3, h4 {
				color: #626262;
			}
			h1 {
				text-align: center;
				margin: 20px !important;
				font-size: 90px;
				padding: 0 !important;
				padding:0 0 10px;
			}
			div.caption {
				font-size: 14px;
				text-align: right;
				margin: auto;
				width: 800px;
				position: relative;
				top: -25px;
				background-color: none;
			}
			a, a.visited {
				color: #004d9b;
				text-decoration: none;
			}
			a:hover {
				text-decoration: underline;
			}
			p.footnote {
				font-size: 12px;
				text-align:right;
				margin-top: 0px;
				position: relative;
				top: -8px !important;
				top: 0px;
			}
			p.about {
				font-size: 12px;
			}
			tr td {
				border-bottom: 1px solid #999;
				vertical-align: top;
			}
			tr th {
				background: #999;
				color: #fff;
			}
			.dsq-item-cp {
				display: none;
			}
			div.trans {
				font-size: 10px;
			}
		</style>
		<script src="http://www.google.com/jsapi"></script>
		<script>
			google.load("mootools", "1.2.2");
		</script>
		<script src="js/Lighter/Ligher.uncompressed.js" type="text/javascript" charset="utf-8"></script>
		
		<script>
        window.addEvent('domready', function(){
            var toc = $$('ul a');
            $$('a:not(.stbutton)').each(function(a) {
                if (toc.contains(a)) return;
                 a.set('target', '_blank');
            });
            if (Browser.Engine.trident) return;
            // Highlight all "pre" elements in a document.
            $$('pre').light({
                altLines: 'hover',
                indent: 2,
                mode: 'pre',
                path: 'js/Lighter/'
            });
        
        });
		</script>
	</head>
	<body>
		<div class="container">

			<h1 class="span-24 last">jQuery vs MooTools</h1>
			<div class="caption">
				May, 2009 - <a href="http://www.clientcide.com" target="_blank">Aaron Newton of Clientcide</a>
				<div class="trans">
					Also available in 
					<a href="/index_pt-br.html">Portuguese (Brazil)</a>. | <a href="http://wiki.github.com/anutron/jquery-vs-mootools">How to submit a translation</a>.
				</div>
			</div>
			<p>
			  La mayoría de la gente que comienza con JavaScript en estos días se encuentra con la desafiante tarea de la elección de la biblioteca a usar, o al menos cual aprender primero. Si estas trabajando para una empresa, probablemente ellos ya han elegido un framework por tí, siendo este caso algo que se puede debatir. Si esta es la situación y ellos eligieron <a href="http://www.mootools.net">MooTools</a> y tu usas normalmente<a href="http://www.jquery.com">jQuery</a>, este artículo puede aún ser de utilidad para ti.
			</p>
			<p>
				<a href="http://twitter.com/joshink/statuses/1671986611">Cada</a> <a href="http://twitter.com/jezusisstoer/statuses/1642244246">día</a> <a href="http://twitter.com/digitalcampaign/statuses/1622094648">en</a> <a href="http://twitter.com/jesswma/statuses/1605733380">twitter</a> veo numerosos posts que caen en la pregutna "MooTools o jQuery?" Este artículo te ayudará a t tomar esa decisión.
			</p>
			<h3>Sobre el Autor</h3>
			<p>
				Soy un programador de MooTools. Trabajo en el framework de MooTools. Escribo sobre MooTools. Yo escribí<a href="http://www.mootorial.com">el principal tutorial online</a> y <a href="http://www.amazon.com/gp/product/1430209836?ie=UTF8&tag=clientside-20&link_code=as3&camp=211189&creative=373489&creativeASIN=1430209836">el libro sobre MooTools</a>. Obviamente, tengo una perspectiva que es algo tendenciosa. Aclarare también que no uso jQuery muy a menudo. Si tu eres un programador de jQuery y ves algo que yo he presentado mal aquí, por favor, contáctame y ayúdame a corregir el incidente. Mi objetivo aqui es ofrecer ayuda y ser conciso para la gente - no intento vender un framework sobre otro.
			</p>

      <h3>Sobre el tradutor</h3>

      <p>Usuario de MooTools, jQuery y de <a href="http://www.workingwithrails.com/person/7271-pedro-visintin">RubyOnRails</a>. Utilizo Clientcide normalmente y mi framework por elección de momento es MooTools.


			<h3>Propósito</h3>
			<p>
				Ayudarte a hacer una elección entre estos dos frameworks me implica mostrarte en qué y cómo difieren los mismos. Comenzaré diciendo que <b>ambos son elecciones excelentes</b>. No puedes hacer una elección incorrecta en estas opciones. Ambos frameworks tienen sus fortalezas y debilidades, pero, en general ambos son excelentes opciones. Hay otros frameworks también que merecen ser evaluados también. <a href="http://www.dojotoolkit.org/">Dojo</a>, <a href="http://www.prototypejs.org/">Prototype</a>, <a href="http://developer.yahoo.com/yui/">YUI</a>, <a href="http://extjs.com/">Ext</a> y otros son todos excelentes opciones. Cual elijas tiene más relación con tu propio estilo y cual es el objetivo a cumplir. El objetivo de este artículo es enfocarnos en MooTools y jQuery, viendo el incremento de la consideración de estos dos frameworks por la gente. Finalmente, no estoy tratando de convencer a nadie de cambiar de un framework al otro. Hay cosas interesantes de estos dos frameworks de las cuales tu puedes aprender. Puedes leer un poco más sobre este artícualo y porqué lo escríbí en <a href="http://www.clientcide.com/3rd-party-libraries/jquery-vs-mootools-mootools-vs-jquery/">mi entrada eb ek blog de Clientcide donde lo he anunciado</a>.
			</p>
			
			<h3>Contenidos</h3>
<ul>
	<li><a href="#mottos">Los Principios lo dicen todo</a></li>
	<li><a href="#learning">La Curva de Aprendizaje y La Comunidad</a></li>
	<li><a href="#javascript">Para qué es bueno JavaScript</a></li>
		<ul style="margin-bottom: 0px">
			<li><a href="#dom">Más que solo el DOM</a></li>
			<li><a href="#inheritance">Herencia con JavaScript</a></li>
			<li><a href="#self">Auto Referencia</a></li>
		</ul>
	</li>
	<li><a href="#jsfun">MooTools Hace JavaScript en sí Más Divertido</a></li>
	<li><a href="#domfun">jQuery Hace el DOM Más Divertido</a></li>
	<li><a href="#cando">Cualquier cosa que hagas yo lo puedo hacer mejor</a></li>
	<li><a href="#yourway">MooTools te permite tenerlo a tu manera</a></li>
	<li><a href="#chaining">Encadenado (Chaining) como un patrón de diseño</a></li>
	<li><a href="#reuse">Reusando código con jQuery</a></li>
	<li><a href="#classes">Reusando código con MooTools</a>
		<ul>
			<li><a href="#mooinheritance">MooTools y Herencia</a></li>
			<li><a href="#extension">Extendiendo e Implementando Clases</a></li>
		</ul>
	</li>
	<li><a href="#conclusion">Tiempo de Decisión</a></li>
	<li><a href="#discussion">Discusión</a></li>
</ul>
		
			<h2>Las Estadísticas</h2>
			<table>
				<tr>
					<th></th>
					<th>jQuery Core</th>
					<th>MooTools Core</th>
				</tr>
				<tr>
					<td>Tamaño de la biblioteca</td>
					<td>55.9K</td>
					<td>64.3K</td>
				</tr>
				<tr>
					<th colspan="3">Prestaciones</th>
				</tr>
				<tr>
					<td>Licencia</td>
					<td><a href="http://en.wikipedia.org/wiki/MIT_License" title="MIT License">MIT</a> &amp; <a href="http://en.wikipedia.org/wiki/GPL" title="GPL">GPL</a></td>
					<td><a href="http://en.wikipedia.org/wiki/MIT_License" title="MIT License">MIT</a></td>
				</tr>
				<tr>
					<td>Utilidades del DOM</td>
					<td>sí</td>
					<td>sí</td>
				</tr>
				<tr>
					<td>Animación</td>
					<td>sí</td>
					<td>sí</td>
				</tr>
				<tr>
					<td>Manejo de Eventos</td>
					<td>sí</td>
					<td>sí</td>
				</tr>
				<tr>
					<td>Selectores CSS3</td>
					<td>sí (un subset)</td>
					<td>sí (un subset)</td>
				</tr>
				<tr>
					<td>Ajax</td>
					<td>sí</td>
					<td>sí</td>
				</tr>	
				<tr>
					<td>Extensiones Natovas (excluyendo Element)</td>
					<td>una docena aprox. para Array, Object, y String</td>
					<td>como seis docenas, para Array, Object, String, Function, y Number</td>
				</tr>
				<tr>
					<td>Herencia</td>
					<td>No soportada directamente con jQuery</td>
					<td>Provista con el constructor<em><a href="http://mootools.net/docs/core/Class/Class">Class</a></em></td>
				</tr>
				<tr>
					<th colspan="3">Otras Consideraciones</th>
				</tr>
				<tr>
					<td>plug-ins</td>
					<td>Cientos de plug-ins no oficiales en un directorio en <a href="http://plugins.jquery.com/">plugins.jquery.com</a></td>
					<td>Apenas 4 docenas de plug-ins oficiales disponibles en <a href="http://mootools.net/more">mootools.net/more</a>. Muchos mas en la web. No hay un catálogo consolidado.</td>
				</tr>
				<tr>
					<td>Biblioteca de UI Oficial</td>
					<td>sí</td>
					<td>no</td>
				</tr>
			</table>
			<p class="footnote">
				Información basada en datos obtenidos de<a href="http://jquery.com">jquery.com</a>, <a href="http://mootools.net">mootools.net</a>, y <a href="http://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks">wikipedia.com</a>.
			</p>
			
			<a name="mottos"></a>
			<h2>Los Principios lo Dicen Todo</h2>
			
		
			<p>
				  Si tu vas al sitio de jQuery, esto es lo que dice en el comienzo de la página:
			</p>
			<blockquote>jQuery es una rápida y concisa Biblioteca de JavaScript que simplifica el recorrido, manejo de eventos, animación, y interacciones Ajax en el documento HTML para un rápido desarrollo web. jQuery está diseñado para cambiar la manera que tu escribes JavaScript.</blockquote>
			<p>
				...y si tu vas a MooTools, esto es lo que vas a encontrar:  
			</p>
			<blockquote>MooTools es un compacto, modular, Object-Oriented JavaScript framework diseñado para el programador JavaScript intermedio a avanzado. Este permite escribir un código potente, flexible, y cross-browser con su elegante, bien documentada y coherente API. </blockquote>
			<p>
				Yo pienso que esto realmente lo resume. Si tu me preguntas (y estás leyendo esto, por lo que asumiré que lo estás haciendo), la pregunta no es sobre cual framework es mejor o peor. La pregunta es, cuales de estas cosas tu quieres hacer? Estos dos frameworks no están tratando de hacer las mismas cosas. Ellos se sobreponesn en la funcionalidad que proveen, pero no están tratando de hacer las mismas cosas.
			</p>
			
			<p>
				La descripción de jQuery's de si mismo habla sobre HTML, eventos, animaciones, Ajax, y desarrollo web. MooTools habla sobre orientacion a objetos y sobre escribir codigo potente y flexible. jQuery aspira a "cambiar la forma que tu escribes JavaScript" mientras que MooTools está diseñado para el programador JavaScript intermedio y avanzado.
			</p>
			
			<p>
				Parte de esta consideración es la noción de un <em>framework</em> vs un <em>toolkit</em>. MooTools es un <em>framework</em> que intenta implementar JavaScript <em>como deberia ser</em> (de acuerdo a los autores de MooTools). El objetivo es implementar un API que se percibe como JavaScript y mejora todo; no solo el DOM. jQuery es un <em>toolkit</em> que te brinda una colección de métodos de fácil uso en un sistema autocontenido diseñado para hacer el DOM en si mismo más amigable. Sucede que la mayoría de la gente se enfoca en el DOM cuando escribe JavaScript, entonces en muchos casos, jQuery es todo lo que necesitas.
			</p>
			<p>
				La mayor parte del código cuando escibis usando MooTools se sigue percibiendo como JavaScript. Si no estås interesado en JavaScript como un lenguaje, aprender MooTools se convertirá en una tarea y no algo placentero. Si estás interesado en JavaScript y lo que lo hace interesante, poderoso, y expresivo, entonces, personalmente, yo pienso que MooTools es la mejor opción.
			</p>
			
			
			<a name="learning"></a>
			<h2>La Curva de Aprendizaje y La Comunidad</h2>
		
			<p>
			  Primero, jQuery es, por lejos, más facil de aprender. Tiene casi un estilo coloquial que uno casi no siente que está programando. Si todo lo que quieres es algo funcionando rápido sin aprender JavaScript, jQuery es probablemente una mejor elección para ti. Esto no significa que MooTools no te puede ayudar a completar las mismas tareas, pero debo admitir que MooTools puede ser un poco mas dificil de acostumbrarse si tu eres nuevo en JavaScript y también encontrarás muchos más recursos para aprender jQuery - más de los que hay para MooTools al menos. 
			</p>
		
			<p>
				Si tu comparas la comunidad jQuery (<a href="http://docs.jquery.com/Discussion">ver la página de "Discussion" en jQuery</a>) y la de la comunidad MooTools (<a href="irc://irc.freenode.net/#mootools">irc</a>, <a href="http://groups.google.com/group/mootools-users">lista de correo</a>, y <a href="http://mooforum.net/">foro no oficial</a>) descubrirás rápidamente dos cosas: 1) la comunidad dejQuery community es <i>por lejos</i> más grande (Yo atribuyo esto mayormente al punto que hice referencia anteriormente sobre cuan fácil es de aprender, pero también porque...) y 2) ellos son más activos promocionando la biblioteca. Si mides jQuery y MooTools en métricas como el número de gente usándolo, el número de consultas hechas en google, el número de libros vendidos, etc, verás a jQuery adelente por un gran margen.
			</p>
		
			<p>
				Para decirte porque debes considerar MooTools primero necesito hablar un poco sobre lo que ambos frameworks hacen. En última instancia el framework que elijas irá dependiendo de que quieres realizar y como te gusta programar (y puede ser también <i>si</i> te gusta programar, al menos en JavaScript)
			</p>
			
			<a name="javascript"></a>
			<h2>Para qué es bueno JavaScript</h2>
		
			<p>
				Parte de hacer esta eleccion es preguntar que es lo que quieres hacer con JavaScript. Consideremos JavaScript básico. Sin ningun framework; solo JS. JavaScript te brinda objetos nativos como <a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Global_Objects/String">Strings</a>, <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Number">Numbers</a>, <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Function">Functions</a>, <a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Global_Objects/Array">Arrays</a>, <a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Global_Objects/Date">Dates</a>, <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/RegExp">Regular Expressions</a>, y más. JavaScript también te brinda un modelo de herencia - una especie de modelo esotérico llamado <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Inheritance">prototypal inheritance</a> (de lo cual voy a profundizar más adelante). Estos bloques de construcción y el concepto de herencia son el pan y la manteca de cualquier lenguaje de programación y nada tienen que ver con los browsers o la web o CSS o HTML. Puedes escribir cualquier cosa que quieras en JavaScript. Ta-te-ti, ajedrez, edición de fotos, un web server, cualquier cosa. Sucede que el 99% de todo el JavaScript que anda por ahí se ejecuta en browsers y eso es como lo pensamos que es. El lenguaje de programación para los browsers.
			</p>
			<p>
				Entendiendo que el browser, el DOM, es solo donde acostumbramos a usar JS la mayoria del tiempo pero saber que JS es actualmente un muy robusto y expresivo lenguaje de programación, te ayudará a entender la diferencia entre MooTools y Jquery.
			</p>
			
			<a name="dom"></a>
			<h3>Mas que solo el DOM</h3>
		
			<p>
				Si piensas que las tareas a realizar en JavaScript estrictamente en términos de "obtener cosas en la página y hacer cosas con eso" entonces jQuery es probablemente la mejor opcion. Este se excede ofreciendo un sistema muy expresivo para describir comportamiento en la página en una manera que hace sentir muchas veces que uno no está programando. Tu puedes aun usar el resto de JavaScript para hacer lo que quieres hace, pero si estas enfocado en el DOM - cambiando propiedades de CSS, animando cosas, obteniendo contenido via AJAX, etc - la mayoría de lo que finalices escribiendo será cubierto por jQuery, y lo que no se asemejará al viejo puro JavaScript. jQuery provee algunos métodos que no aplican al DOM; por ejemplo, jQuery provee un mecanismo para iterar sobre arrays - <i><a href="http://docs.jquery.com/Utilities/jQuery.each">$.each(array, fn)</a></i> - o, por ejemplo, ofrece un método trim para strings - <i><a href="http://docs.jquery.com/Utilities/jQuery.trim">$.trim(str)</a></i>. Pero no hay una gran cantidad de estos métodos utilitarios, lo cual está bien porque, para la mayor parte, si tu estas obteniendo cosas del DOM, iterando sobre el, y alterándolo de alguna manera (agregando html, cambiando estilos, agregando eventos y listeners para click y mouseover, etc) no necesitaras mucho más que esto.
			</p>
			<p>
				Pero si pensas en el alcance de JavaScript en su espectro completo, podes ver que Jquery no hace foco en las cosas fuere del DOM. Esta es una de las razones porqué es tan sencillo de aprender, pero esto también limita la forma en que te ayuda a escribir JavaScript. Este solo no esta tratando de ser ninguna otra cosa que un sistema solido de programacion <i>para el DOM</i>. No provee herencia ni proevee las utilidades básicas para todos los tipos nativos del lenguaje JavaScript, <i>pero no necesita hacerlo</i>. Si quieres meterte en el manejo de strings, fechas, expresiones regulares, arrays y funciones, <i>tu puedes</i>. No es el trabajo de jQuery ayudarte a hacerlo. JavaScript como lenguaje está ahi a tus pies. jQuery hace del DOM su cancha de juego, pero el resto de JavaScript no está en su alcance.
			</p>
			<p>
				Aqui es donde MooTools is vástamente diferente. En vez de enfocarse exclusivamente en el DOM (Rather than focusing exclusively on the DOM (a pesar de, como veremos en breve, este ofrece toda la funcionalidad que jQuery tiene pero lo alcanza de una muy diferente manera), MooTools tome dentro de su alcance el lenguaje completo. Si jQuery hace del DOM su cancha de juego, MooTools intenta hacer a JavaScript su cancha de juego, y esa es una de las razones por la cuale es mas dificil de aprender.
			</p>
			
			<a name="inheritance"></a>
			<h3>Herencia con JavaScript</h3>
		
			<p>
				Hay algunas cosas fascinantes sogre el lenguaje de programación JavaScript. Para los que empiezan, este es un <a href="http://en.wikipedia.org/wiki/Functional_programming">lenguaje funcional</a>, lo que significa que maneja las funciones como los objetos de mayor orden que pueden ser pasados a través de variables como cualquier otro objeto - strings o números por ejemplo. Está diseñado con este concepto en mente y muchos de los métodos y patrones en el trabajan mejor cuando escribes codigo de esa manera. Esta es la diferencia entre:
			</p>
<pre class="js">for (var i = 0; i &lt; myArray.length; i++) { /* hace algo */ }</pre>
			<p>
				  and          
			</p>
			<pre class="js">myArray.forEach(function(item, index) { /* hace algo */ });</pre>
			<p>
				  JavaScript tiene un <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Inheritance">modelo de herencia</a> que no es particularmente único pero bastante poco común en lenguajes de programación. En vez de clases que son definidas y pueden tener subclases éste pasa los comportamientos a través de <i><a href="http://en.wikipedia.org/wiki/Prototype-based_programming">herencia prototipada (prototypal inheritance)</a></i>. Esto significa que los objetos heredan directamente de otros objetos. Si referencias una propiedad de un objeto que hereda de otro objeto, el lenguaje inspecciona el objeto hijo por esa propiedad y, si no la encuentra, busca a ella en el padre. De esta manera es como trabaja un array. Cuando tipeas: 
			</p>
			<pre class="js">[1,2,3].forEach(function(item) { alert(item) }); //esto hace alert 1 despues  2 despues 3</pre>
			<p>
				el método "<a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:forEach">forEach</a>" no es una propiedad del array que declaraste (<em>[1,2,3]</em>), este es una propiedad del prototipo para todos los Arrays. Cuando referencias este método el lenguaje busca un método llamado <em>forEach</em> en tu array, y, si no lo encuentra, busca entonces en el prototipo de todos los arrays. Esto significa que el método <em>forEach</em> no está en memoria por cada array existente; éste está solo en la memoria del prototipo de arrays. Esto es increiblemente eficiente y bastante potente. (Nota: MooTools hace un alias de el metodo <em>forEach</em> llamándolo <em>each</em>)
			</p>
			
			<a name="self"></a>
			<h3>Autoreferencia</h3>
			<p>
				Javascript tiene una palabra especial: "this". Esto es dificil para mi definir en forma resumida de que se trata este "this", por defecto, "this" es el objeto del cual se asocia el método corriente. Este permite a los objetos referise a si mismos, ya que de otro modo no tendrían la forma para hacerlo. Esto se vuelve importante cuando creas objetos hijos y tienes numerosas instancias de ese objeto; de qué otra manera el método de un objeto podria referise a sí mismo? Cuando la copia actual del método existe en el objeto padre, no en el hijo, la palabra "this" permite a estas instancias referirse a su propio estado. (<a href="http://www.quirksmode.org/js/this.html">aquí hay una descripcion mucho más completa sobre la palabra "this"</a>, y <a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Operators/Special_Operators/This_Operator">otra de Mozilla</a>.)
			</p>
			<p>
				  La palabra "this" permite a los objetos que heredan de otros objetos referirse a si mismos, pero hay veces donde quieres que se referencie a algo mas a través de "this". Esto es llamado <a href="http://alternateidea.com/blog/articles/2007/7/18/javascript-scope-and-binding">binding</a>, en donde especificas un "this" <i>different</i> para un método. El método "each" en un Array te permite especificar el objeto que será retornado cuando utilices "this" como segundo argumento. Aquí hay un ejemplo de donde deseamos usar un "this" diferente:
			</p>
<pre class="js">var ninja = {
    weapons: ['katana', 'throwing stars', 'exploding palm technique'],
    log: function(message) {
        console.log(message);
    },
    logInventory: function() {
        this.weapons.each(function(weapon) {
			//queremos que "this" esté apuntando a ninja...
            this.log('this ninja can kill with its ' + weapon);
        }, this); //entonces pasamos "this" (que es ninja) al método Array.each  
    }
};
ninja.logInventory(); 
//this ninja can kill with its katana
//this ninja can kill with its throwing stars
//this ninja can kill with its exploding palm technique</pre>

			<p>
				En el ejemplo anterior, nosotros enlazamos o asociamos (bound) ninja (el cual es "this" dentro de el método <em>logInventory</em>) al método que pasamos al array de esta manera podremos hacer referencia a la propiedad de log de ninja. Si no hicieramos esto "this" será <em>window</em>.
</p>
			<p>
			  Estos son solo algunos ejemplos del poder y expresividad que JavaScript tiene para ofrecer - herencia, autoreferencia y enlace o asociación, y eficientes propiedades de prototipos. Las malas noticias es que el viejo JavaScript básico, no hace accessibles ni útiles estas poderosas cosas, y aquí es donde MooTools <i>comienza</i>. MooTools hace que estos tipos de patrones sean fáciles y porqué no placenteros de usar. Terminarás escribiendo código más abstracto, y en el largo plazo, esto es algo bueno - algo potente. Aprendiendo como estos patrones son valiosos y como usar ellos apropiadamente lleva esfuerzo, pero el lado bueno es que el código que escribes es altamente reusable y mucho más facil de mantener. Voy a hablar de estas dos cosas en un poco mas de un minuto.
			</p>
			
			<a name="jsfun"></a>
			<h2>MooTools hace JavaScript en sí Más Divertido</h2>
		
			<p>
			  MooTools se enfoca en hacer la API de JavaScript en sí más estable y coherente, está menos enfocado en brindarte una interfáz que "cambia la manera que escribis JavaScript" y más en hacer a JavaScript como un todo menos frustrante; MooTools es una extensión del lenguaje JavaScript. MooTools intenta hacer a JavaScript de la forma que debería ser. Una porción significante de la biblioteca principal esta dedicada mejorar Function, String, Array, Number, Element y otros prototipos. La otra gran cosa es que ofrece una función llamada <em><a href="http://mootools.net/docs/core/Class/Class">Class</a></em>.
			</p>
			<p>
				Ahora, <em>Class</em> se ve para muchas personas como un intento de recrear una manera más clasica del modelo de herencia que uno podría encontrar en Java o C++, pero ese <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Class-Based_vs._Prototype-Based_Languages">no es el caso</a>. Lo que <em>Class</em> realmente hace es hacer el modelo de herencia prototipada de JavaScript más sencillo para ti y para mi de acceder y tomar ventaja de ello. Notar qeu estos conceptos nos son únicos a MooTools (otros frameworks ofrecen similar funcionalidad), pero estos dos conceptos no estan presentes en jQuery. jQuery no ofree un sistema de herencia ni ofrece ninguna mejora a los objetos nativos (Funciton, String, etc). Esto no es una deficiencia de jQuery ya que los autores de jQuery podrían fácilmente ofrecer estas cosas. En cambio, ellos han diseñado un toolkit con una meta diferente con otra idea en la cabeza. Donde MooTools intenta hacer JavaScript mas divertido, jQuery intenta hacer el DOM más divertido y los diseñadores han elegido limitar su alcance para esa taréa.
			</p>
			
			<a name="domfun"></a>
			<h2>jQuery Hace el DOM Más Divertido</h2>
		
			<p>
			  Y esto es por qué jQuery es más accesible. El no te pide que aprendas JavaScript al derecho y al revés. El no te empuja dentro de las profundidades de herencia prototipada, enlazado, "this" y prototipos nativos. Cuando comienzas con jQuery en este <a href="http://docs.jquery.com/Tutorials:How_jQuery_Works">tutorial oficial</a>, 
éste es el primer código ejemplo de jQuery con que te vas a encontrar:
			</p>
		
<pre class="js">window.onload = function() {
    alert("welcome");
}</pre>

			<p>y aquí está el tercero: </p>

<pre class="js">$(document).ready(function() {
    $("a").click(function(event) {
        alert("Thanks for visiting!");
    });
});</pre>

			<p>
				Si lees <a href="http://www.amazon.com/gp/product/1430209836?ie=UTF8&tag=clientside-20&link_code=as3&camp=211189&creative=373489&creativeASIN=1430209836">el libro de  MooTools</a> o el <a href="http://www.mootorial.com/wiki">tutorial de MooTools </a> (ambos escritos por mi) ellos comienzan en un lugar muy diferente. Mientras puedes saltar adelante y rápidamente aprender los efectos y el DOM, si quieres aprender MooTools, tendras que empezar con cosas como <em>Class</em>, y, debo admitir: si sos nuevo en programacion, o simplemente quieres algo funcionando en tu sitio sin tener que aprender todo de JavaScript, jQuery te parecerá mucho más amigable.     
			</p>
			
			<p>
				Del otro lado, si quieres aprender JavaScript, MooTools es una excelente manera de hacerlo. Implementa un monton de cosas que JavaScript tendrá (muchos de los métodos en Natives son simplemente los de la especificación <a href="https://developer.mozilla.org/En/New_in_JavaScript_1.8">JavaScript 1.8</a> y posteriores). Si estas acostumbrado a programar, especialmente de ambas maneras, orientado a objetos y programación funcional, MooTools tiene un montón de patrones de diseño que son muy interesantes y expresivos.
			</p>
			
			<a name="cando"></a>
			<h2>Cualquier cosa que hagas Yo lo puedo hacer mejor</h2>
		
			<p>
			  Si miras las cosas que jQuery puede hacer, siempre hay una contraparte en MooTools. Si miras las cosas que MooTools puede hacer, no siempre encontraras su contraparte en jQuery debido a que jQuery se enfoca en el DOM. MooTools tiene tiene una funcionalidad más amplia que jQuery, pero no hay nada en jQuery que evite que las hagas. Por ejemplo, jQuery no viene con ninguna clase de sistema de herencia, pero eso está bien. Tu podrias, si quieres, usar MooTools <em>Class</em> en conjunto con jQuery si lo deseas (o escribir tu propia implementación). Hay incluso <a href="http://code.google.com/p/jquery-inheritance/updates/list">un plug-in de herencia para jQuery</a> (No lo he usado, pero asumo que ofrece el mismo tipo de funcionalidad).
			</p>
	
			<p>Si miramos al ejemplo anterior de jQuery:</p>  
		
<pre class="js">$(document).ready(function() {
    $("a").click(function(event) {
        alert("Thanks for visiting!");
    });
});</pre>
		
			<p>
				y queremos traducirlo a MooTools, tendríamos que hacer:  
			</p>
<pre class="js">window.addEvent('domready', function() {
    $$('a').addEvent('click', function(event) {
        alert('Thanks for visiting!');
    });
});</pre>
			<p>
				  Muy similares no?          
			</p>
			<p>
				  Este es un ejemplo de jQuery un poco más complejo:          
			</p>

<pre class="js">$(document).ready(function() {
    $("#orderedlist li:last").hover(function() {
        $(this).addClass("green");
    },
    function() {
        $(this).removeClass("green");
    });
});</pre>

			<p>
	    y en MooTools:  
			</p>

<pre class="js">window.addEvent('domready',function() {
    $$('#orderedlist li:last').addEvents({
        mouseenter: function() {
            this.addClass('green');
        },
        mouseleave: function() {
            this.removeClass('green');
        }
    });
});</pre>

			<p>
				De nuevo, muy similares. Debo mostrar que la versión de MooTools es más explícita, pero tambíen más verborrágica a causa de ello. Queda claro leyendo el código de MooTools que estamos agregando dos eventos - uno para cuando el mouse entra y otro cuando el mouse sale, mientras que la versión de jQuery es más concisa; su método <em><a href="http://docs.jquery.com/Events/hover">hover</a></em> acepta dis métodos - el primero para cuando el mouse entra y otro para cuando sale. Me gusta mas, personalmente, el hecho de que el código de MooTools es más legible pero esa es una observación muy subjetiva. 
			</p>
			
			<p>
			  Voy a decir que jQuery a veces puede volverse demasiado esotérico para mi gusto. Los métodos no siempre me transmiten sobre qué hacen cuando los miro y lo encuentro dificil para recorrerlos. Esto es algo injusto creo, porque yo estoy intimamente relacionado con MooTools, por lo tanto leer MooTools es fácil para mi. Pero una de las cosas que aprecio de MooTools es cómo casi todos los métodos y clases realmente definen lo que son. Los métodos son casi siempre verbos y dejan muy poca duda sobre lo que hacen. Cada lenguaje de programación requiere de la lectura de la referencia y de la sintaxis cuando escribes código - No estoy diciendo eso. Yo solo digo que encuentro el API de MooTools más coherente y consistente.
			</p>
			
			<a name="yourway"></a>
			<h2>MooTools te permite tenerlo a tu manera</h2>
			
			<p>Pero, que pasa si te gusta la sintaxis de jQuery? Una forma de ilustrar el poder de MooTools es mostrarte cuán fácil es cambiarlo para que quede como te gusta. Si queremos implementer el método <em>hover</em> de jQuery en MooTools, podemos hacerlo fácilmente así:</p>
			
<pre class="js">Element.implement({
    hover : function(enter,leave){
       return this.addEvents({ mouseenter : enter, mouseleave : leave });
    }
});

//entonces tu puedes usarlo exactamente como la versión de jQuery:
$$('#orderlist li:last').hover(function(){
   this.addClass('green');
},
function(){
   this.removeClass('green');
});
</pre>

		<p>De hecho, hay plug-ins de MooTools que justamente hacen eso; <a href="http://github.com/cheeaun/mooj/tree/master">ofreciendo la sintaxis de jQuery en MooTools</a>. Que MooTools esté enfocado en la extensibilidad significa que puedes implementar lo que quieras. Esto es algo que jQuery no puede hacer. MooTools puede emular jQuery si lo quieres, pero jQuery no puede emular MooTools. Si deseas escribir clases o extender prototipos nativos o hacer alguna de las otras cosas que MooTools puede, lo tendrás que escribir todo tú mismo.</p>
		
			<a name="chaining"></a>
			<h2>Encadenado (Chaining) como un patrón de diseño</h2> 
		
			<p>
				  Hagamos otro de estos. Aqui estan algunos ejemplos de jQuery (del tutorial de jQuery):
			</p>

<pre class="js">$(document).ready(function() {
    $('#faq').find('dd').hide().end().find('dt').click(function() {
        $(this).next().slideToggle();
    });
});</pre>

			<p>
				  Este es un ejemplo de una sintaxis que personalmente no prefiero. Mirando al codigo anterior estoy fuertemente presionado a asegurarme de que es lo que está haciendo. Más notablemente estoy curioso sobre que es lo que hace <i>.end</i> y como despues hace <i>.find</i>, el cual está contiguo, relacionado a lo que hace <i>.end</i>? Ahora bien, mirando la referencia de jQuery nos deja bienl claro que es lo que .end hace (éste vuelve al valor del selector original, en este caso #faq). Pero esto se ve muy extraño para mí. Cuando trabajo con jQuery, a menudo, me encuentro inseguro sobre lo que un método irá a devolverme. Obviamente esto no le preocupa a nadie mas siendo que jQuery tiene un monton de gente usándolo felizmente, por lo tanto lo marcare nuevamente como una preferencia personal.
			</p>
			<p>
				      Miramos la lógica anterior desde MooTools:  
			</p>

<pre class="js">window.addEvent('domready', function() {
    var faq = $('faq');
    faq.getElements('dd').hide();
    faq.getElements('dt').addEvent('click', function() {
        this.getNext().slide('toggle');
    });
});
</pre>


			<p>
			Nuevamente, el código de MooTools es un poco más verborrágico, pero también, más explícito. Nota también que el patrón de diseño aquí es almacienar la referencia a #faq en una variable, donde jQuery usa el método <i>.end</i> para devolverla. Quiero notar que es posible escribir código con mucho encadenamiento en MooTools. Por ejemplo:
			</p>
<pre class="js">item.getElements('input[type=checkbox]')
	.filter(function(box) {
		return box.checked != checked;
	})
	.set('checked', checked)
	.getParent()[(checked) ? 'addClass' : 'removeClass']('checked')
	.fireEvent((checked) ? 'check' : 'uncheck');</pre>
			
			<p>
			  Pero realmente, escribir codigo como este - un montón de lógica en una sentencia de domready - con cualquier framework, yo sostengo, que en sí misma es una mala práctica. Es por lejos mucho mejor encapsular la lógica en partes reutilizables.
			</p>
			
			<a name="reuse"></a>
			<h2>Reusando código con jQuery</h2>
			
			<p>
			  Es muy tentador cuando estas trabajando en un proyecto web para escribir código de esta manera. Solo agregas un poco de lógica en la página que selecciona los elementos del DOM y "los prepara" ocultando algunos, alterando otros, y agregando listeners para click o mouseover. Desarrollar código en esta manera es muy eficiente, y muy rápido. El problema con escribir toda tu lógica en las sentencias de domready es que terminarás con un montón de código que hace la misma cosa en diferentes lugares. Si tomamos el patron de FAQ anterior nosotros podemos aplicar esa lógica fácilmente en cualquier otra página con cualquier lista de términos y definiciones. Vamos a repetir la misma lógica cada vez que encontremos este patrón?
			</p>
			<p>
				   A simple way to make it reusable is to wrap the logic in a function and pass in arguments. Here's what that might look like in jQuery: 
			</p>

<pre class="js">function faq(container, terms, definitions) {
    $(container).find(terms).hide().end().find(definitions).click(function() {
        $(this).next().slideToggle();
    });
};
$(document).ready(function() {
    faq('#faq', 'dd', 'dt');
});</pre>

			<p>
				This is much better for two really big and important reasons:  
			</p>
			<ol>
				<li>
					 If tomorrow we need to change how these lists work (maybe we want to add click tracking logic so we can measure it in our web logs or maybe we want to fetch the definitions via ajax) we can just change our main <i>faq</i> method and everywhere we use it just gets updated. Or if there's a new version of jQuery released that changes the way things work, we can just go update our one method instead of a dozen copies everywhere. I call this  keeping a small footprint in my application. By keeping the points where my application touches my more generic code as small as possible, it makes it easier for me to fix bugs, upgrade frameworks, add features, or alter functionality. 
				</li>
				<li>
					 The second reason is that it's less code. By reusing the same method over and over again, I don't repeat myself and this is valuable in any programming environment. It also makes the code my visitors have to download smaller. 
				</li>
			</ol>  
			<p>
				jQuery actually has a slightly more refined system for writing reusable "widgets" like these. Rather than encourage you to drop them into functions like the above example (which is really rather crude) it encourages you to write <a href="http://docs.jquery.com/Plugins/Authoring">jQuery plug-ins</a>. Here's what that would look like:  

<pre class="js">jQuery.fn.faq = function(options) {
    var settings = jQuery.extend({
        terms: 'dt',
        definitions: 'dd'
    }, options); 
	//"this" is the current context; in this case, the elements we want to turn into faq layouts
    $(this).find(settings.terms).hide().end().find(settings.definitions).click(function() {
        $(this).next().slideToggle();
    });
    return this;
};</pre>

			</p>
			    which you would use thusly:
			</p>
	<pre class="js">$('#faq').faq();</pre>

			<p>
				But looking at the example above, there's not much difference between declaring our <i>faq</i> function this way vs. declaring it as a stand alone function. Granted, it's not in the global namespace, but we could have just as easily added it to a namespace of our own. By attaching it to jQuery we can chain it with other jquery methods. The other benefit is that the "this" inside our function is the current context of whatever is in the jQuery chain at that moment. By using this pattern for plug-ins we're able to make our plug-in look like it's part of jQuery, but other than that, our plug-in is basically a single function that takes the current jQuery context, does stuff to it, and then returns the context for the next item in the chain. There's not a lot of complexity here, which makes it easy for anyone to write jQuery plug-ins - they're just single functions.
			</p>

			<p>
				Note that it is possible to write more complex plugins with jQuery with methods and state. This kind of pattern is supported with the jQuery UI plugin system and doesn't use the same mechanism as the basic plugin (like our faq example). Instead, you attach an object with methods and properties to the jQuery object (i.e. <em>$.ui.tabs</em>). There's a shortcut to invoke this object (<em>$(selector).tabs()</em>) so that you can continue chaining as with the faq plugin. But because it doesn't return a reference to the tabs object created for the items in your selector, you're forced to call that selector again to invoke methods on it. Instead of calling <em>myTabInstance.add(url, label, index)</em> you must execute the selector again and call your function by name (as a string): <em>$(selector).tabs('add', url, label, index);</em>. This means you're running your selector twice (unless you store it in a variable somewhere), and that you don't ever have a pointer to the "add" method that you can do things like bind or delay. This post is focused on the MooTools and jQuery cores, and while jQuery's UI system does provide this functionality, it's not something that comes with jQuery by default.
			</p>

			<a name="classes"></a>
			<h2>Reusing Code with MooTools</h2>

			<p>
				In MooTools when you want to define a pattern, you're more likely to use either a <em><a href="http://mootools.net/docs/core/Class/Class">Class</a></em> or implement a method into a native object (into <em>String</em>, for example).
			</p>
		
			<p>
				Rather than give you an almost completely different language from JavaScript's native style, MooTools attempts to walk the middle ground between defining its own custom syntax and extending JavaScript's own design patterns. One of the ways it does this is by extending the prototypes of the native objects in the language and in the DOM. This means that if you needed a method to trim a string, MooTools encourages you to add that method to String itself (note that <em><a href="http://mootools.net/docs/core/Native/String#String:trim">String.trim</a></em> is already in MooTools; you don't need to add this yourself):
			</p>

<pre class="js">String.implement({
    trim: function() {
        return this.replace(/^\s+|\s+$/g, '');
    }
});</pre>

			<p>
				This means you can just execute <i>" no more spaces on the end! ".trim()</i> and get back <i>"no more spaces on the end!"</i>. Some would say that implementing properties into native prototypes is inappropriate. It's the reason why MooTools and <a href="http://www.prototypejs.org/">Prototype.js</a> can't play well with each other - any framework that manipulates prototypes of natives doesn't play well with any other framework that does the same. If I define <i>String.prototype.foo()</i> and another library on the same page defines it, too, which ever one comes last wins. In a way, this is similar to the problem we face with the global window namespace. This is how JavaScript works. This is how <a href="https://developer.mozilla.org/En/New_in_JavaScript_1.8">JavaScript 1.8</a> has added so many features. It adds them to the prototypes.
			</p>
			<p>	
				The MooTools developers include a robust framework that is easy for you to extend with your own functionality with the intention that people who include the framework in the page are going to use it, not some other framework. It's actually kind of rude to ask users to download two frameworks. The only reason to include two frameworks is because you want to use plug-ins from both, and in the minds of the MooTools authors (myself included), if you want a plug-in that isn't available with the framework of your choice, it's more appropriate for you to spend the time porting it to your environment than to ask your users to download another framework.
			</p>
			<p>
				Once you learn how JavaScript works and see the power of extending native objects, a whole new level of programming opens up. You can write plug-ins that alter Elements or Dates or Functions. While some might argue that adding methods to natives this way is a kind of pollution, I'd argue that this is how JavaScript is meant to be used. It is a design feature of the language. By attaching methods to natives you allow your code to be concise and compartmentalized. jQuery does this too, but limits its prototype	enhancements to the jQuery object.
			</p>
			
			<p>
				While you can easily chain multiple method calls on the jQuery object, on any other type of object you have to use
			generics. For example, in jQuery if you want to trim a string and then iterate over each line, you would have to write:
			</p>

			<pre class="js">$.each( $.trim( $('span.something').html() ).split("\n"), function(i, line){alert(line);});</pre>

			<p>But because MooTools modifies prototypes, you can do this:</p>

			<pre class="js">$('span.something').get('html').trim().split("\n").each(function(line){alert(line);});</pre>

			<p>
				Taking a look at this makes it extremely clear how powerful it is to
			modify prototypes. Chaining on DOM elements isn't the only place chaining is
			useful. MooTools lets you chain methods on any object, including
			running a method on multiple elements at once.
			</p>
			
			<p>
				The key here is that at the heart of the MooTools framework is the notion that it's there to let you program what you want. If there's functionality that's not in the core, you can extend it and add your own. The job of the core is not to provide everyone with every bit of functionality that they could ever want, but to provide the tools that allow you write the things that you want. A big part of that is making it easier to extend the prototypes of natives, and take advantage of prototypal inheritance. You can do these things with vanilla JavaScript but MooTools makes it easier and more pleasant.
				
			</p>
			
			
			<a name="mooinheritance"></a>
			<h3>MooTools and Inheritance</h3>
		
			<p>
				Despite its name, the MooTools <em>Class</em> function is not really a class nor does it create them. It has design patterns that might remind you of classes in a more traditional programming language, but really <em>Class</em> is all about objects and prototypal inheritance. (Unfortunately, using words like "class" are the most convenient way to describe these things, so for the purposes of this article, when I refer to "classes" I'm referring to functions that return objects - which I'll "instances" - that inherit from a prototype.)
			</p>
			<p>
				To make a class, you pass an object to the <em>Class</em> constructor like this:
			</p>
		
<pre class="js">var Human = new Class({
    initialize: function(name, age) {
        this.name = name;
        this.age = age;
    },
    isAlive: true,
    energy: 1,
    eat: function() {
        this.energy = this.energy + 1; //same as this.energy++
    }
});</pre>
		
			<p>
				You pass <em>Class</em> an object (above, we pass an object with members like "isAlive" and "eat") and this object becomes the prototype of every instance of that class. To create an instance, you call it like this:
			</p>
<pre class="js">var bob = new Human("bob", 20); //bob's name is "bob" and he's 20 years old.</pre>
			<p>
				Now we have an instance of <em>Human</em>. <em>bob</em> has the properties of the object we defined when we created our <em>Human</em> class. But the important thing is that <em>bob</em> has these properties through inheritance. When we reference <i>bob.eat</i>, <i>bob</i> doesn't really have this property. JavaScript looks at <i>bob</i> and he doesn't have an <i>eat</i> method, so it looks up the inheritance chain and finds it on the object we passed when we created the <em>Human</em> class. This is true for <i>energy</i>, too. At first glance this looks potentially bad; we don't want all the humans we create to gain energy every time that <i>bob</i> eats. The important thing to recognize is that the first time we assign a value to <i>bob</i>'s energy, we assign him his own value and we no longer look at the prototype for it. So the first time <i>bob</i> eats, he gets his own definition for <em>energy</em> (set to 2).
			</p>
			<pre class="js">bob.eat(); //bob.energy == 2</pre>
			<p>
				Note that <em>bob</em>'s name and age are unique to him; these are assigned to him when the class is initialized in the <i>initialize</i> method.
			</p>
			<p>
				This whole pattern may seem a little odd to you, but the value here is that we can define functionality for a pattern and create instances of that pattern every time we need it. Each instance maintains its own state. So if we create another instance each one is independent of the other, but inherits from the same base pattern:
			</p>
		
<pre class="js">var Alice = new Human();
//alice.energy == 1
//bob.energy == 2</pre>
		
			<p>
				Where things get really interesting is when we want to augment this behavior.
			</p>
			
			<a name="extension"></a>
			<h3>Extending and Implementing Classes</h3>
		
			<p>
				Let's revisit our jQuery <i>faq</i> plug-in. What would happen if we wanted to add more functionality to that plug-in. What if we wanted to make an ajax version that fetched the answers to the questions from the server? Let's imagine that the <i>faq</i> plug-in was authored by someone else and we want to add more to it without altering it in any way (we don't want to fork it).
			</p>
			<p>
				Our only real choices are to either duplicate the <em>faq</em> plug-in's logic entirely (remember, it's a single function), essentially forking it, or we can invoke it and then add more logic to it. Given a choice, the latter seems to save us the most trouble. It would look something like this:
			</p>
<pre class="js">jQuery.fn.ajaxFaq = function(options) {
    var settings = jQuery.extend({ 
		//some ajax specific options like the url to request terms from
        url: '/getfaq.php'
        definitions: 'dd'
    }, options); 
	//"this" is the current context; in this case, the elements we want to turn into faq layouts
    $(this).find(settings.definitions).click(function() {
        $(this).load(.....); //the logic to load the content from the term
    });
    this.faq(); //call our original faq plug-in
});</pre>
			<p>
				This has some down sides. First of all, our <em>faq</em> class is going to repeat our selector for the definitions, which might be expensive; there's no way to store the retrieved definitions and pass it on for the second time they are needed. Secondly, we can't add our ajax logic into the middle of the <em>faq</em> plug-in's own logic for displaying the definition. The original plug-in called <em>slideToggle</em> which expands the definition using an effect. This is problematic because this effect is going to go off before our ajax finishes loading. There's no real solution here unless we just duplicate the entire <em>faq</em> plug-in.
			</p>
			<p>
				Now let's consider our MooTools <em>Human</em> class. It has properties like <em>isAlive</em> and <em>energy</em> and it has a method called <em>eat</em>. What if we wanted to make a new version of <em>Human</em> that had additional properties? With MooTools, we extend the class:
			</p>
<pre class="js">var Ninja = new Class({
    Extends: Human,
    initialize: function(name, age, side) {
        this.side = side;
        this.parent(name, age);
    },
    energy: 100,
    attack: function(target) {
        this.energy = this.energy - 5;
        target.isAlive = false;
    }
});</pre>
			<p>
				You can see that we've added a lot of functionality here into a subclass. This subclass has all these properties that are unique to <em>Ninjas</em>. <em>Ninjas</em> start off with an initial <em>energy</em> value of 100. <em>Ninjas</em> get a <em>side</em>. They also get an <em>attack</em> method that lets them kill other <em>Humans</em>, but it costs the <em>Ninja</em> energy.
			</p>

<pre class="js">var bob = new Human('Bob', 25);
var blackNinja = new Ninja('Nin Tendo', 'unknown', 'evil');
//blackNinja.isAlive = true
//blackNinja.name = 'Nin Tendo'
blackNinja.attack(bob);
//bob never had a chance</pre>

			<p>
				Picking this apart a bit, there are some interesting things to consider here. Note that we have an <em>initialize</em> method in the <em>Ninja</em> class. This would appear to overwrite the <em>initialize</em> method in the <em>Human</em> class, but we can still access it by calling <em>this.parent</em>, passing along the arguments that the parent class's <em>initialize</em> expects. Further, we can control when our logic occurs; before or after the call to the parent. We can assign new values to properties (like the <em>energy</em> value) and we can define new functionality. Imagine if we could do this with our <em>faq</em> plug-in for jQuery. We could load our ajax and THEN slide open the value.
			</p>
			<p>
				MooTools has another pattern called a Mixin. Unlike the parent to
				child relationship that is defined by extending one class into a
				subclass, you can also define classes that are mixed into other
				classes to imbue them with their properties. Here's an example:
			</p>

<pre class="js">var Warrior = new Class({
    energy: 100,
    kills: 0,
    attack: function(target) {
        target.isAlive = false;
        this.energy = this.energy - 5;
        this.kills++;
    }
});</pre>

			<p>
				Here we've broken the qualities that make a <em>Ninja</em> different from a <em>Human</em> and put them in a class of their own. This lets us reuse this code outside of <em>Ninja</em>. We could then imbue our <em>Ninja</em> class with the qualities of a warrior like so:
			</p>

<pre class="js">var Ninja = new Class({
    Extends: Human,
    Implements: Warrior, //can be an array if you want to implement more than one
    initialize: function(name, age, side) {
        this.side = side;
        this.parent(name, age);
    }
});</pre>
		
			<p>
				<em>Ninja</em> still works as it did before, but <em>Warrior</em> is at our disposal to reuse:
			</p>

<pre class="js">var Samurai = new Class({
  Extends: Human,
  Implements: Warrior,
  side: 'good'
});</pre>

			<p>
				Now we have a <em>Samurai</em> class and a <em>Ninja</em> class. But look at how little code both <em>Ninja</em> and <em>Samurai</em> took to define. Both of them are similar in that they are humans with warrior qualities, but they are different in that samurais are always, always good, while ninjas have shifting allegiances. By spending the time to write a <em>Human</em> class and a <em>Warrior</em> class, we're able to have three different classes with no repetition of code while maintaining a very granular level of control over when methods are called and how they relate to each other. Each instance we create has its own state and the code itself is very legible.
			</p>
			
			<p>
				Now that you have an overview of how classes work in MooTools, let's look at our <em>faq</em> class that we wrote in jQuery and write it as we would in MooTools and then extend it to add Ajax to it just as we did with jQuery.				
			</p>
<pre class="js">
var FAQ = new Class({
	//Options is another class provided by MooTools
	Implements: Options,
	//these are the default options
	options: {
		terms: 'dt',
		definitions: 'dd'
	},
	initialize: function(container, options) {
		//we store a reference to our container
		this.container = $(container);
		//setOptions is a method provided by the Options mixin
		//it merges the options passed in with the defaults
		this.setOptions(options);
		//we store the terms and definitions
		this.terms = this.container.getElements(this.options.terms);
		this.definitions = this.container.getElements(this.options.definitions);
		//we call our attach method
		//by breaking this into its own method
		//it makes our class easier to extend
		this.attach();
	},
	attach: function(){
		//loop through the terms
		this.terms.each(function(term, index) {
			//add a click event to each one
			term.addEvent('click', function(){
				//that calls our toggle method for
				//the current index
				this.toggle(index);
			}, this);
		}, this);
	},
	toggle: function(index){
		//toggle open the definition for the given index
		this.definitions[index].slide('toggle');
	}
});
</pre>

			<p>
				Woah. That's a lot of code. Even if we remove all the comments it's still two dozen lines long. I already illustrated above that we could build this plug-in with roughly the same amount of code as the jQuery version. So why is this one so much longer? Well, we've made it much more flexible. To use the class, we just call the constructor, like this:
			</p>

<pre class="js">var myFAQ = new FAQ(myContainer);
//and now we can call methods on it if we want:
myFAQ.toggle(2); //toggle the 3rd element
</pre>

			<p>
				We can access methods and properties of the instance. But what about our ajax functionality? The problem with our ajax extension to the jQuery version was that we couldn't delay the opening of the definition until after it loaded. We don't have that problem with our MooTools version:
				
			</p>

<pre class="js">FAQ.Ajax({
	//this class inherits the properties of FAQ
	Extends: FAQ,
	//it also gets a new option in addition to the other defaults
	//this one for url, that we're going to append the index of the
	//term to; in reality we might make this more robust, but for
	//this example it serves the purpose
	options: {
		url: null;
	},
	//we're going to cache the results, so if a section is opened
	//twice, we won't hit the server for the data
	indexesLoaded: [],
	toggle: function(index){
		//if we've already loaded the definition
		if (this.indexesLoaded[index]) {
			//just call the previous version of toggle
			this.parent(index);
		} else {
			//otherwise, request the data from the server
			new Request.HTML({
				update: this.definitions[index],
				url: this.options.url + index,
				//and when the data is loaded, expand the definition
				onComplete: function(){
					this.indexesLoaded[index] = true;
					this.definitions[index].slide('toggle');
				}.bind(this)
			}).send();
		}
	}
});
</pre>

			<p>
				Now we have a version of our <em>FAQ</em> class that allows us to get the definitions from the server. Note that we were able to integrate the new logic in a way that doesn't expand the definition until <em>after</em> the content comes back from the server (which we couldn't do with the jQuery version). Also note that we really only had to describe the new functionality (the ajax) and little else. This extensibility makes it possible for you to create families of plug-ins that offer different shades of functionality. It also means that you can use someone else's plug-in and alter just the bits that you to be want different if you need to (without forking it). This helps explain why, for any given design pattern - a date picker, a tab interface, etc, that you typically only find a few plug-ins for MooTools. Most of the plug-ins you get either solve your problem or, if not, you can just extend them to add the things you need.
				
			</p>
			
			<p>
				As I illustrated earlier, it's possible to write complex jQuery widgets with methods and state. Most of the code you write when doing this is vanilla JavaScript when you need to express logic that isn't related to the DOM. But jQuery's model doesn't offer a system for extending these instances into subclasses. Nor does it help you with mixins that can be reused easily. Finally, jQuery's plugins are always attached to DOM elements. If you wanted to write a class that, say, processed URLs, there's no stateful system for such a thing unless you write it yourself.
			</p>
			
			<a name="conclusion"></a>
			<h2>Decision Time</h2>
		
			<p>
				jQuery focuses on expressiveness, quick and easy coding, and the DOM while MooTools focuses on extension, inheritance, legibility, reuse, and maintainability. If you put those two things on opposite sides of a scale, the jQuery side translates into something with which it's easy to get started and see quick results but (in my experience) can turn into code that's harder to reuse and maintain (but really that's up to you; it's not jQuery's problem, per se), while the MooTools side takes longer to learn and requires you to write more code upfront before you see results, but afterwards is more reusable and more maintainable.
			</p>
			<p>
				Further, the MooTools core does not contain every feature you can imagine and neither does the jQuery core. Both frameworks keep their cores rather lean, leaving it to you and others to write plug-ins and extensions. Their job is not to give you every feature you could want but to give you the tools so that you can implement anything you can imagine. This is the power of JavaScript, and of JavaScript frameworks in general, and both frameworks excel at it. MooTools takes a more holistic approach and gives you tools to write anything you can imagine beyond the scope of the DOM, but pays the price by having a steeper learning curve. MooTools extensibility and holistic approach gives you a superset of jQuery's features, but jQuery's focus on a slick DOM API doesn't preclude you from using the native inheritance methods of JavaScript or from using a class system like MooTools if you want it.
			</p>
			<p>
				This is why I say that both frameworks are excellent choices. My effort here has been to highlight the differences in philosophies between the two codebases and highlight their advantages and disadvantages. I doubt I've been successful in keeping my preference for MooTools completely in check, but hopefully this has been helpful. Regardless of which framework you choose to work with, you now know a lot more about both, hopefully. If you have the luxury of time, I strongly recommend implementing a site with each. Then write your own review of them both and maybe your perspective will highlight some things I missed.
			</p>
			<p>A history of this document <a href="http://github.com/anutron/jquery-vs-mootools/tree/master">can be viewed on github</a>.</p>
			<p>
			<script type="text/javascript" src="http://w.sharethis.com/button/sharethis.js#publisher=c327065b-efa0-4e12-afbc-5717f5cf62f9&amp;type=website&amp;post_services=facebook%2Cdigg%2Cdelicious%2Ctwitter%2Creddit%2Cfriendfeed%2Cmyspace%2Cybuzz%2Cstumbleupon%2Ctechnorati%2Cmixx%2Cblogger%2Cwordpress%2Ctypepad%2Cgoogle_bmarks%2Cwindows_live%2Cfark%2Cbus_exchange%2Cpropeller%2Cnewsvine%2Clinkedin"></script>
			</p>
			<hr/>
			<p class="about">
				About me: I am a <a href="http://www.mootools.net">MooTools</a> contributor and I blog about JavaScript and other things on my site <a href="http://www.clientcide.com">Clientcide</a> as well as release <a href="http://www.clientcide.com/js">numerous plug-ins for MooTools</a>. I am the author of <a href="http://www.amazon.com/gp/product/1430209836?ie=UTF8&tag=clientside-20&link_code=as3&camp=211189&creative=373489&creativeASIN=1430209836">MooTools Essentials</a> as well as the <a href="http://www.mootorial.com">MooTools online tutorial</a>. I work at a company in the SF Bay Area called <a href="http://www.cloudera.com">Cloudera</a>. <a href="http://www.clientcide.com/shout-out">I can be contacted thusly</a>.
			</p>
			
			<a name="discussion"></a>
			<hr/>
			<p class="about" style="color: #700"><strong>A note on comments here</strong>: These comments are moderated. No comments will show up until they are approved. Comments that are not productive (i.e. inflammatory, rude, etc) will not be approved. Similarly, "fan" comments won't be approved either - i.e. no "FrameworkX Rulez! It's better than FrameworkY for realz!" are not constructive comments.
			</p>
			<div id="disqus_thread"></div><script type="text/javascript" src="http://disqus.com/forums/jqueryvsmootools/embed.js"></script>
		</div>
		<script type="text/javascript">
		var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
		document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		</script>
		<script type="text/javascript">
		try {
		var pageTracker = _gat._getTracker("UA-539314-11");
		pageTracker._trackPageview();
		} catch(err) {}</script>
		
		<script type="text/javascript">
		//<![CDATA[
		(function() {
				var links = document.getElementsByTagName('a');
				var query = '?';
				for(var i = 0; i < links.length; i++) {
					if(links[i].href.indexOf('#disqus_thread') >= 0) {
						query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
					}
				}
				document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/jqueryvsmootools/get_num_replies.js' + query + '"></' + 'script>');
			})();
		//]]>
		</script>
		
	</body>
</html>