<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<title>
			jQuery vs MooTools: Come scegliere tra due i grandi framework JavaScript
		</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<link rel="Shortcut Icon" href="favicon.ico" type="image/x-icon">
		<link rel="stylesheet" href="css/blueprint/screen.css" type="text/css" media="screen, projection">
		<link rel="stylesheet" href="css/blueprint/print.css" type="text/css" media="print">	
		<!--[if IE]><link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->
		<link rel="stylesheet" href="css/blueprint/src/typography.css" type="text/css" media="screen" title="no title" charset="utf-8">
		<style>
			body { 
			  font-size: 100%;
			  color: #444; 
			  background: #fff;
			  font-family: "Georgia", Arial, Helvetica, sans-serif;
			}
			h1, h2, h3, h4 {
				color: #626262;
			}
			h1 {
				text-align: center;
				margin: 20px !important;
				font-size: 90px;
				padding: 0 !important;
				padding:0 0 10px;
			}
			div.caption {
				font-size: 14px;
				text-align: right;
				margin: auto;
				width: 800px;
				position: relative;
				top: -25px;
				background-color: none;
			}
			a, a.visited {
				color: #004d9b;
				text-decoration: none;
			}
			a:hover {
				text-decoration: underline;
			}
			p.footnote {
				font-size: 12px;
				text-align:right;
				margin-top: 0px;
				position: relative;
				top: -8px !important;
				top: 0px;
			}
			p.about {
				font-size: 12px;
			}
			tr td {
				border-bottom: 1px solid #999;
				vertical-align: top;
			}
			tr th {
				background: #999;
				color: #fff;
			}
			.dsq-item-cp {
				display: none;
			}
			div.trans {
				font-size: 10px;
			}
			ul#dsq-comments {
				max-height:800px !important;
				overflow:auto !important;
				padding:0 10px 0 0 !important;
			}
		</style>
		<script src="http://www.google.com/jsapi"></script>
		<script>
			google.load("mootools", "1.2.2");
		</script>
		<script src="js/Lighter/Ligher.uncompressed.js" type="text/javascript" charset="utf-8"></script>
		
		<script>
        window.addEvent('domready', function(){
            var toc = $$('ul a');
            $$('a:not(.stbutton)').each(function(a) {
                if (toc.contains(a)) return;
                 a.set('target', '_blank');
            });
            if (Browser.Engine.trident) return;
            // Highlight all "pre" elements in a document.
            $$('pre').light({
                altLines: 'hover',
                indent: 2,
                mode: 'pre',
                path: 'js/Lighter/'
            });
        
        });
		</script>
	</head>
	<body>
		<div class="container">

			<h1 class="span-24 last">jQuery vs MooTools</h1>
			<div class="caption">
				May, 2009 - <a href="http://www.clientcide.com" target="_blank">Aaron Newton of Clientcide</a><br />
  				Traduzione di <a href="http://www.lorenzostanco.com">Lorenzo Stanco</a> e <a href="http://www.steweb.it">Stefano Ceschi Berrini</a>
				<div class="trans">
					Also available in 
					<a href="/index_pt-br.html">Portuguese (Brazil)</a>, <a href="/index_cn.html">Chinese</a>, <a href="index_fa.html">Farsi (Persian)</a> and <a href="/index_es-ar.html">Spanish</a>. | <a href="http://wiki.github.com/anutron/jquery-vs-mootools">How to submit a translation</a>.
				</div>
			</div>
			<p>
				Sempre pi&ugrave; spesso chi si avvicina alla programmazione in JavaScript si imbatte nella difficile scelta della libreria da adottare, o quantomeno della prima da imparare. Se lavori all'interno di un team probabilmente gi&agrave; ti &egrave; stato imposto un framework, con motivazioni pi&ugrave; o meno discutibili. Se questo &egrave; il tuo caso, se sei costretto a usare <a href="http://www.mootools.net">MooTools</a> ma sei pratico con <a href="http://www.jquery.com">jQuery</a>, allora questo articolo pu&ograve; ugualmente esserti d'aiuto.
			</p>
			<p>
				<a href="http://twitter.com/joshink/statuses/1671986611">Ogni</a> <a href="http://twitter.com/jezusisstoer/statuses/1642244246">giorno</a> <a href="http://twitter.com/digitalcampaign/statuses/1622094648">su</a> <a href="http://twitter.com/jesswma/statuses/1605733380">Twitter</a> leggo innumerevoli post del tipo "MooTools o jQuery?". Questo articolo vuole aiutarti a scegliere.
			</p>
			<h3>Premessa</h3>
			<p>
				Sono uno sviluppatore MooTools. Lavoro sul framework MooTools. Scrivo un blog su MooTools. Ho scritto <a href="http://www.mootorial.com">il principale tutorial online</a> e <a href="http://www.amazon.com/gp/product/1430209836?ie=UTF8&tag=clientside-20&link_code=as3&camp=211189&creative=373489&creativeASIN=1430209836">il libro su MooTools</a>. Ovviamente ho una visione che &egrave; in qualche modo di parte. E ammetto anche di non usare molto spesso jQuery. Se sei uno sviluppatore jQuery e pensi che abbia travisato qualcosa, ti prego di contattarmi e aiutarmi a rimediare l'errore. Il mio obiettivo &egrave; quello di esser d'aiuto - non quello di vendere un framework piuttosto che un'altro.
			</p>

			<h3>Scopo</h3>
			<p>
				Aiutarti a scegliere tra questi due framework significa per me spiegartene le differenze. Comincio col dire che <b>entrambi sono scelte eccellenti</b>. Non esiste la scelta sbagliata. Entrambi i framework hanno i loro punti di forza e le loro debolezze, ma, in generale, sono entrambi ottime scelte. Ci sono anche ulteriori framework che fanno bene il loro lavoro. <a href="http://www.dojotoolkit.org/">Dojo</a>, <a href="http://www.prototypejs.org/">Prototype</a>, <a href="http://developer.yahoo.com/yui/">YUI</a>, <a href="http://extjs.com/">Ext</a> e altri ancora sono ottime opzioni. La scelta, in verit&agrave;, ha pi&ugrave; a che fare con il tuo stile personale e con i tuoi bisogni. L'articolo si concentra su MooTools e jQuery, in quanto sono sempre pi&ugrave; i framework presi in considerazione dalla maggior parte delle persone. Non cercher&ograve; di convincere nessuno a passare da un framework a un'altro. Entrambi offrono spunti interessanti da cui &egrave; possibile imparare molto. Se vuoi saperne di pi&ugrave; su questo articolo e del perch&eacute; l'ho scritto puoi leggere il <a href="http://www.clientcide.com/3rd-party-libraries/jquery-vs-mootools-mootools-vs-jquery/">mio post sul blog di Clientcide</a>.
			</p>
			
			<h3>Indice</h3>
<ul>
	<li><a href="#mottos">Il Motto Dice Tutto</a></li>
	<li><a href="#learning">La Curva di Apprendimento e la Community</a></li>
	<li><a href="#javascript">I Punti di Forza di JavaScript</a></li>
		<ul style="margin-bottom: 0px">
			<li><a href="#dom">Non Solo il DOM</a></li>
			<li><a href="#inheritance">L'Ereditariet&agrave; in JavaScript</a></li>
			<li><a href="#self">Autoreferenza</a></li>
		</ul>
	</li>
	<li><a href="#jsfun">MooTools Rende JavaScript Pi&ugrave; Divertente</a></li>
	<li><a href="#domfun">jQuery Rende il DOM Pi&ugrave; Divertente</a></li>
	<li><a href="#cando">Qualunque Cosa Tu Faccia Posso Farla Meglio</a></li>
	<li><a href="#yourway">MooTools Fa Ci&ograve; Che Vuoi Come Vuoi</a></li>
	<li><a href="#chaining">La Concatenazione Come Design Pattern</a></li>
	<li><a href="#reuse">Riutilizzo del Codice con jQuery</a></li>
	<li><a href="#classes">Riutilizzo del Codice con MooTools</a>
		<ul>
			<li><a href="#mooinheritance">L'Ereditariet&agrave; in MooTools</a></li>
			<li><a href="#extension">Estendere ed Implementare le Classi</a></li>
		</ul>
	</li>
	<li><a href="#conclusion">&Egrave; ora di decidere</a></li>
	<li><a href="#discussion">Commenti</a></li>
</ul>
		
			<h2>Qualche dato</h2>
			<table>
				<tr>
					<th></th>
					<th>jQuery Core</th>
					<th>MooTools Core</th>
				</tr>
				<tr>
					<td>Dimensione</td>
					<td>55.9K</td>
					<td>64.3K</td>
				</tr>
				<tr>
					<th colspan="3">Caratteristiche</th>
				</tr>
				<tr>
					<td>Licenza</td>
					<td><a href="http://en.wikipedia.org/wiki/MIT_License" title="MIT License">MIT</a> &amp; <a href="http://en.wikipedia.org/wiki/GPL" title="GPL">GPL</a></td>
					<td><a href="http://en.wikipedia.org/wiki/MIT_License" title="MIT License">MIT</a></td>
				</tr>
				<tr>
					<td>Strumenti per il DOM</td>
					<td>s&igrave;</td>
					<td>s&igrave;</td>
				</tr>
				<tr>
					<td>Animazioni</td>
					<td>s&igrave;</td>
					<td>s&igrave;</td>
				</tr>
				<tr>
					<td>Gestione degli eventi</td>
					<td>s&igrave;</td>
					<td>s&igrave;</td>
				</tr>
				<tr>
					<td>Selettori CSS3</td>
					<td>s&igrave; (un sottoinsieme)</td>
					<td>s&igrave; (un sottoinsieme)</td>
				</tr>
				<tr>
					<td>Ajax</td>
					<td>s&igrave;</td>
					<td>s&igrave;</td>
				</tr>	
				<tr>
					<td>Estensioni ai tipi nativi (eccetto Element)</td>
					<td>circa una dozzina per Array, Object e String</td>
					<td>circa sei dozzine per Array, Object, String, Function e Number</td>
				</tr>
				<tr>
					<td>Ereditariet&agrave;</td>
					<td>Non supportata direttamente da jQuery</td>
					<td>Fornita col costruttore <em><a href="http://mootools.net/docs/core/Class/Class">Class</a></em></td>
				</tr>
				<tr>
					<th colspan="3">Altre considerazioni</th>
				</tr>
				<tr>
					<td>Plugin</td>
					<td>Centinaia di plugin non ufficiali su <a href="http://plugins.jquery.com/">plugins.jquery.com</a></td>
					<td>Circa 4 dozzine di plugin ufficiali disponibili su <a href="http://mootools.net/more">mootools.net/more</a>. Plugin non ufficiali su <a href="http://mootools.net/plugins">mootools.net/plugins</a>.</td>
				</tr>
				<tr>
					<td>Libreria ufficiale per la UI</td>
					<td>s&igrave;</td>
					<td>no</td>
				</tr>
			</table>
			<p class="footnote">
				Informazioni basate sui dati forniti da <a href="http://jquery.com">jquery.com</a>, <a href="http://mootools.net">mootools.net</a> e <a href="http://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks">wikipedia.com</a>.
			</p>
			
			<a name="mottos"></a>
			<h2>Il motto dice tutto</h2>
			
		
			<p>
				  Se si v&agrave; sul sito di jQuery, all'inizio della pagina c'&egrave; scritto:
			</p>
			<blockquote>jQuery è una libreria Javascript veloce e concisa che semplifica la navigazione del documento HTML, la gestione degli eventi, le animazioni e le interazioni Ajax per un rapido sviluppo web. jQuery &egrave; progettato per cambiare il modo in cui si scrive Javascript.</blockquote>
			<p>
				...mentre se si va' sul sito di MooTools, ecco cosa si trover&agrave; scritto:
			</p>
			<blockquote>MooTools &egrave; un framework Javascript Object-Oriented compatto e modulare, progettato per lo sviluppatore Javascript medio/avanzato. Permette di scrivere codice potente, flessibile e cross-browser con le sue eleganti, ben documentate e coerenti API.</blockquote>
			<p>
				Penso che questo dica gi&agrave; tutto. Se mi stai per domandare (e stai leggendo, quindi assumo che tu lo stia facendo), la domanda non &egrave; quale sia il framework migliore o peggiore. &Egrave; quale delle cose scritte qui sopra vuoi fare? Questi due frameworks non stanno cercando di fare le stesse cose. Si sovrappongono un po' rispetto alle funzionalita' che mettono a disposizione, ma non stanno cercando di fare le stesse cose.
			</p>
			
			<p>
			  La descrizione di jQuery stesso parla di HTML, eventi, animazioni, Ajax e sviluppo web. MooTools parla di orientamento agli oggetti (OOP) e riguarda lo scrivere codice potente e flessibile. jQuery aspira a "cambiare il modo di scrivere Javascript" mentre MooTools &egrave; progettato per lo sviluppatore Javascript medio/avanzato.
			</p>
			
			<p>
			  Parte di questa considerazione deriva dalla nozione di <em>framework</em> vs <em>toolkit</em>. MooTools &egrave; un <em>framework</em> che cerca di implementare JavaScript <em>come dovrebbe essere</em> (in accordo con gli autori di MooTools). Lo scopo &egrave; quello di implementare una API che sembra JavaScript puro e che lo esalti; non riguarda solamente il DOM. jQuery &egrave; un <em>toolkit</em> che mette a disposizione un insieme di metodi facili da utilizzare in un sistema progettato per rendere il DOM stesso piu' piacevole. Accade spesso che il DOM sia l'area in cui la maggior parte delle persone scrive JavaScript, quindi in molti casi, jQuery &egrave; tutto quello che serve.
			</p>
			<p>
			  Quando si scrive codice con MooTools si ha la sensazione di scrivere JavaScript puro. Se non si &egrave; interessati riguardo al JavaScript come linguaggio, imparare MooTools può sembrare una cosa di troppo. Se si &egrave; invece interessati a JavaScript ed in particolare a cosa lo rende interessante, la potenza e l'espressivita', beh, personalmente, penso che MooTools sia la scelta migliore.
			</p>
			
			
			<a name="learning"></a>
			<h2>La Curva di Apprendimento e la Community</h2>
		
			<p>
			  Per prima cosa, jQuery &egrave; sicuramente piu facile da imparare. Ha uno stile quasi colloquiale che non ti fa sentire di star programmando. Se tutto quello che interessa &egrave; ottenere qualcosa che funzioni velocemente senza dover imparare JavaScript, jQuery &egrave; probabilmente la scelta migliore. Non che MooTools non aiuti ad ottenere gli stessi risultati, ma ammetto che può essere più ostico da imparare se se si &egrave; principianti in JavaScript ed in più ci sono moltissime risorse che aiutano ad imparare jQuery - almeno, più di quelle che ci sono per imparare MooTools.
			</p>
		
			<p>
			  Se si confronta la community di jQuery (<a href="http://docs.jquery.com/Discussion">vedere la pagina "discussioni" nel sito di jQuery</a>) con quella di MooTools (<a href="irc://irc.freenode.net/#mootools">irc</a>, <a href="http://groups.google.com/group/mootools-users">mailing list</a>, e <a href="http://mooforum.net/">forum non ufficiale</a>) si scopriranno velocemente due cose: 1) quella jQuery &egrave; nettamente piu estesa (attribuisco questo maggiormente rispetto al punto che ho menzionato sopra riguardo la facilit&agrave; di apprendimento, ma anche perchè...) 2) loro sono molto attivi nel promuovere la libreria. Se si misurano jQuery e MooTools in base a metriche come il numero di persone che lo utilizzano, il numero di query di ricerca su google, il numero di libri venduti, etc, si notera' che jQuery stravince.
			</p>
		
			<p>
			  Per dirvi perch&egrave; dovreste considerare MooTools dovrò prima mostrarvi cosa fanno sostanzialmente questi due frameworks. Il framework che si sceglier&agrave; dovr&agrave; rispettare lo scopo che ci si &egrave; posti ed il proprio metodo di programmazione (ed anche forse <i>se</i> piace programmare, almeno in JavaScript).
			</p>
			
			<a name="javascript"></a>
			<h2>I Punti di Forza di JavaScript</h2>
		
			<p>
			  Parte della decisione sta nel domandarsi che cosa si vuole fare con Javascript. Consideriamo il JavaScript base. Senza nessun framework; solamente vecchio e puro JS. Mette a disposizione oggetti nativi come
			  <a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Global_Objects/String">Strings</a>, <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Number">Numbers</a>, <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Function">Functions</a>, <a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Global_Objects/Array">Arrays</a>, <a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Global_Objects/Date">Dates</a>, <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/RegExp">Espressioni regolari</a>, e pi&ugrave;. Inoltre predispone un modello di ereditariet&agrave; - un qualche esoterico modello chiamato <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Inheritance">ereditariet&agrave; prototipale</a> (a riguardo ci torner&ograve; pi&ugrave; avanti). Questi blocchi portanti ed il concetto di ereditariet&agrave; sono pane e burro di ogni linguaggio di programmazione e non hanno assolutamente niente a che vedere con i browsers o con il web o con CSS o HTML. Si potrebbe scrivere qualsiasi cosa si voglia con JavaScript. Tris, scacchi, photo editing, un server web, qualunque cosa. Il fatto &egrave; che il 99% di tutto il JS che c'&egrave; in giro lo vediamo eseguire nei browsers ed &egrave; in questo contesto che lo pensiamo. Ossia il linguaggio di programmazione per il browser.
			</p>
			<p>
			  Sapere che il browser, il DOM, &egrave; l'area dove la maggior parte delle volte utilizziamo JavaScript ma che quest'ultimo &egrave; anche un liguaggio di programmazione molto robusto ed espressivo aiuter&agrave; a capire le differenze tra MooTools e jQuery.
			</p>
			
			<a name="dom"></a>
			<h3>Non Solo il DOM</h3>
		
			<p>
			  
			  Se si pensa a cosa si vuole fare con JavaScript in termini di "prendere elementi nella pagina per farne qualcosa" allora jQuery &egrave; probabilmente la scelta migliore. Eccelle nell'offrire un sistema molto espressivo per descrivere il comportamento nelle pagine in un modo che quasi non sembra programmazione vera e propria. Si pu&ograve; sempre continuare ad usare il resto in JavaScript per fare quello che si vuole, ma se si &egrave; focalizzati sul DOM - per cambiare propriet&agrave; CSS, animare elementi, recuperare dei contenuti via Ajax, etc - tutto quello che si vorr&agrave; fare sar&agrave; ottenibile tramite jQuery, pi&ugrave; qualcosa - se mancante in jQuery - in vecchio e puro JavaScript. jQuery mette anche a disposizione metodi che non riguardano prettamente il DOM; ad esempio, offre un meccanismo per iterare sugli array - <i><a href="http://docs.jquery.com/Utilities/jQuery.each">$.each(array,fn)</a></i> - oppure, ad esempio, offre un metodo per il trim delle stringhe - <a href="http://docs.jquery.com/Utilities/jQuery.trim">$.trim(str)</a></i>. Ma non sono presenti molti metodi di questo tipo, che &egrave; un bene, perch&egrave;, per la maggior parte, se si stanno solo prendendo elementi dal DOM, ci si itera sopra, e li si altera (aggiungendo html, cambiando stili, aggiungendo dei listener per eventi quali click e mouseover, etc) non serve molto altro.
			</p>
			<p>
			  Ma se si pensa al JavaScript nella sua totalit&agrave;, si pu&ograve; notare come jQuery non si focalizzi in cose al di fuori del DOM. Questa &egrave; una delle ragioni per cui &egrave; cos&igrave; facile da imparare, ma altres&igrave; limita il modo in cui pu&ograve; aiutare a scrivere JavaScript. Sta solamente cercando di essere nientemeno che un solido sistema di programmazione per il DOM. Non prevede ereditariet&agrave; e nemmeno dispone di utilit&agrave; per tutti i tipi nativi del linguaggio JavaScript, ma non ne ha la necessit&agrave;. Se si vogliono fare magie con stringhe, date, espressioni regolari, array e funzioni, &egrave; possibile. Ma aiutare in questo non &egrave; compito di jQuery. JavaScript come linguaggio &egrave; quello che serve. jQuery rende il DOM il tuo ambiente, ma il resto del linguaggio JavaScript &egrave; fuori dalla sua ottica.
			</p>
			<p>
			  &Egrave; qui dove si differenzia maggiormente MooTools. Piuttosto che focalizzarsi esclusivamente sul DOM (comunque, e ci torner&ograve; piu avanti, offre tutte le stesse funzionalit&agrave; di jQuery ma consegue lo scopo in maniera totalmente differente), MooTools prende sotto suo dominio tutto l'intero linguaggio. Se jQuery rende il DOM l'ambiente operativo, MooTools mira a rendere tutto JavaScript come ambiente operativo, e questa &egrave; una delle ragioni per cui &egrave; pi&ugrave; ostico da imparare.
			</p>
			
			<a name="inheritance"></a>
			<h3>L'Ereditariet&agrave; in JavaScript</h3>
		
			<p>
			  Il linguaggio di programmazione JavaScript offre alcune cose veramente fantastiche a riguardo. Per i principianti, &egrave; un <a href="http://en.wikipedia.org/wiki/Functional_programming">linguaggio funzionale</a>, significa che tratta le funzioni come oggetti di ordine superiore che possono essere passati come variabili praticamente come tutti gli altri oggetti - stringhe o numeri ad esempio. &Egrave; progettato con questo concetto nella mente e molti dei metodi e dei pattern presenti funzionano al meglio quando il codice viene scritto in questo modo. &Egrave; la differenza tra: 
			</p>
<pre class="js">for (var i = 0; i &lt; myArray.length; i++) { /* fai qualcosa */ }</pre>
			<p>
				  e
			</p>
			<pre class="js">myArray.forEach(function(item, index) { /* fai qualcosa */ });</pre>
			<p>
			    JavaScript ha un <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Inheritance">modello di ereditariet&agrave;</a> che non &egrave; unico ma piuttosto raro nei linguaggi di programmazione. Invece dell'ereditariet&agrave; a classi (una classe pu&ograve; essere sottoclasse etc) JS vira verso l'ereditariet&agrave; prototipale. Questo significa che gli oggetti ereditano direttamente da altri oggetti. Se si referenzia una propriet&agrave; in un oggetto che eredita da un altro oggetto, il linguaggio ispeziona l'oggetto figlio per quella propriet&agrave; e, se non la trova, la cerca nel padre. Questo &egrave; il modo in cui funziona sugli array. Quando si scrive:
			</p>
			<pre class="js">[1,2,3].forEach(function(item) { alert(item) }); //alert di 1 poi 2 ed infine 3</pre>
			<p>
			  il metodo "<a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:forEach">forEach</a>" non &egrave; una propriet&agrave; dell'array che viene dichiarato ([1,2,3]), ma &egrave; una propriet&agrave; del prototipo per tutti gli Array. Quando si referenzia questo metodo il linguaggio cerca forEach nell'array, e, non trovandolo, guarda all'interno del prototipo 'padre' di tutti gli array. Questo significa che il metodo forEach non &egrave; in memoria per ogni array dichiarato; &egrave; in memoria soltanto per il prototipo degli array. In due parole: efficienza e potenza. (nota: l'alias utilizzato in MooTools per forEach &egrave; each)
			</p>
			
			<a name="self"></a>
			<h3>Autoreferenza</h3>
			<p>
			  In JavaScript esiste una keyword speciale: "this". &Egrave; difficile per me in poche parole definirla ma, di default, "this" &egrave; l'oggetto al quale il metodo corrente appartiene. Permette agli oggetti di riferirsi a se stessi all'interno dei loro metodi, in quanto altrimenti non avrebbero altri mezzi per farlo. Tutto questo inizia a diventare importante quando si creano ogetti figli e numerose istanze di quell'oggetto; come altro potrebbe il metodo di un oggetto riferirsi all'oggetto stesso? Quando la copia attuale del metodo esiste nel padre, non nel figlio, la keyword "this" permette a queste istanze di riferirsi al loro stato. (<a href="http://www.quirksmode.org/js/this.html">qui c'&egrave; una piu completa descrizione a riguardo</a>, ed <a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Operators/Special_Operators/This_Operator">un'altra da Mozilla</a>)
			</p>
			<p>
			  La keyword "this" permette agli oggetti che ereditano da altri oggetti di riferirsi a loro stessi, ma ci sono volte in cui si vorrebbe far riferimento a qualcos altro attraverso il "this". Questo procedimento &egrave; chiamato <a href="http://alternateidea.com/blog/articles/2007/7/18/javascript-scope-and-binding">binding</a>, ossia quando si specifica un "this" <i>diverso</i> per un metodo. Il metodo "each" (del tipo Array) permette di specificare l'oggetto a cui far riferimento attraverso un secondo argomento. Qui sotto c'&egrave; un esempio che esplica il passaggio di un "this" differente:
			</p>
<pre class="js">var ninja = {
    weapons: ['katana', 'throwing stars', 'exploding palm technique'],
    log: function(message) {
        console.log(message);
    },
    logInventory: function() {
        this.weapons.each(function(weapon) {
			//vogliamo che "this" faccia riferimento a ninja...
            this.log('this ninja can kill with its ' + weapon);
        }, this); //quindi passiamo "this" (che e' ninja) ad Array.each
    }
};
ninja.logInventory(); 
//this ninja can kill with its katana
//this ninja can kill with its throwing stars
//this ninja can kill with its exploding palm technique</pre>

			<p>
			  Nell'esempio qui sopra, "leghiamo" ninja (che &egrave; il "this" dentro al metodo <em>logInventory</em>) al metodo che passiamo all'array in modo che ci si possa riferire alla propriet&agrave; log di ninja. Se non l'avessimo fatto, "this" sarebbe stato <em>window</em>.
			</p>
			<p>
			  Questi sono solamente alcuni esempi del potere e dell'espressivit&agrave; che JavaScript ha da offrire - ereditariet&agrave;, auto referenza e binding, ed efficienti propriet&agrave; prototipali. La brutta notizia riguarda il fatto che JavaScript puro non rende queste cose potenti molto usabili o accessibili, ed &egrave; qui che <i>entra in gioco</i> MooTools. Rende questi tipi di pattern semplici ed anche piacevoli da usare. Si finisce per usare codice piu astratto, ed a lungo andare, &egrave; una buona cosa - una cosa potente. Capire come questi patterns siano preziosi e come usarli correttamente richiede uno sforzo, ma la cosa positiva &egrave; che il codice che si scrive &egrave; molto pi&ugrave; riusabile e facile da manternere. Andro' nei dettagli a riguardo tra un minuto.
			</p>
			
			<a name="jsfun"></a>
			<h2>MooTools Rende JavaScipt Pi&ugrave; Divertente</h2>
		
			<p>
			  Dato che MooTools si focalizza nel rendere le API JavaScript stesse piu stabili e coerenti, perde un p&ograve; nel dare un'interfaccia che "cambia il modo in cui si scrive JavaScript" e nel rendere JavaScript nell'insieme meno frustrante; MooTools &egrave; un'estensione del liguaggio JavaScript. MooTools prova a rendere il JavaScript com'&egrave; stato pensato. Una parte significante del "core" &egrave; viene utilizzata per arricchire Funzioni, Stringhe, Array, Number, Element ed altri prototipi. L'altra enorme cosa che offre &egrave; una funzione chiamata <em><a href="http://mootools.net/docs/core/Class/Class">Class</a></em>.
			</p>
			<p>
			  Ora, attraverso <em>Class</em> sembrerebbe si stesse cercando di ricreare un pi&ugrave; classico modello di ereditariet&agrave; che si puo trovare in Java o C++, ma <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Class-Based_vs._Prototype-Based_Languages">non &egrave; cos&igrave;</a>. Quello che fa <em>Class</em> &egrave; rendere il modello di ereditariet&agrave; prototipale del JavaScript pi&ugrave; facile ed accessibile e qualcosa da cui prendere vantaggio. Da notare che questi concetti non sono unici in MooTools (altri frameworks offrono funzionalit&agrave; similari), ma non sono presenti in jQuery. Quest'ultimo non offre un sistema di ereditariet&agrave; n&egrave; offre estensioni per gli oggetti nativi (Function, String, etc). Sia chiaro, non &egrave; un difetto di jQuery, in quanto i suoi autori potrebbero rendere facilmente disponibili queste cose. Loro hanno invece progettato un toolkit con un obiettivo diverso in mente. Dove MooTools mira a rendere JavaScript pi&ugrave; divertente, jQuery mira a rendere il DOM pi&ugrave; divertente ed i progettisti hanno scelto di limitare i loro scopi a questi compiti.
			</p>
			
			<a name="domfun"></a>
			<h2>jQuery Rende il DOM Pi&ugrave; Divertente</h2>
		
			<p>
			  Ed &egrave; per questo che jQuery &egrave; pi&ugrave; accessibile. Non presuppone che si impari JavaScript in lungo ed in largo. Non mette di fronte l'ereditariet&agrave; prototipale, binding, "this" e prototipi nativi. Quando si inizia a scrivere codice con jQuery tramite il <a href="http://docs.jquery.com/Tutorials:How_jQuery_Works">tutorial ufficiale</a>, questo &egrave; il primo esempio che ci si trova davanti:
			</p>
		
<pre class="js">window.onload = function() {
    alert("benvenuto");
}</pre>

			<p>e qui c'&egrave; il terzo: </p>

<pre class="js">$(document).ready(function() {
    $("a").click(function(event) {
        alert("Grazie della visita!");
    });
});</pre>

			<p>
			  Se si legge il <a href="http://www.amazon.com/gp/product/1430209836?ie=UTF8&tag=clientside-20&link_code=as3&camp=211189&creative=373489&creativeASIN=1430209836">libro su MooTools</a> oppure il <a href="http://www.mootorial.com/wiki">tutorial MooTools</a> (dei quali ne sono l'autore) questi approcciano in maniera completamente differente. Mentre si pu&ograve; saltare gran parte ed andare direttamente ad imparare cose su effetti e DOM, se si vuol imparare seriamene MooTools, bisognerebbe iniziare con cose come <em>Class</em>, e, lo ammetto: se si &egrave; alle prime armi con la programmazione, o si vuol solamente qualcosa che funzioni nel proprio sito senza approfondire il linguaggio JavaScript, jQuery sicuramente risulter&agrave; molto pi&ugrave; semplice ed "amichevole".
			</p>
			
			<p>
			  D'altra parte, se si vuol veramente imparare JavaScript, MooTools &egrave; un gran bel mezzo per riuscirci. Implementa molte cose che JavaScript deve ancora avere (molti dei metodi che estendono i tipi nativi sono solo le specifiche <a href="https://developer.mozilla.org/En/New_in_JavaScript_1.8">js 1.8</a> ed oltre). Se si &egrave; abituati a programmare, specialmente sia programmazione orientata agli oggetti che funzionale, MooTools offre tantissimi design patterns interessanti ed espressivi.
			</p>
			
			<a name="cando"></a>
			<h2>Qualunque Cosa Tu Faccia, Io Posso Farla Meglio</h2>
		
			<p>
			  Se si guarda a quello che jQuery pu&ograve; fare, c'&egrave; sempre una stessa funzionalit&agrave; in MooTools. Riguardo quello che MooTools pu&ograve; fare, non c'&egrave; modo a volte di emularle in codice jQuery dato che quest'ultimo si focalizza solamente sul DOM. MooTools ha pi&ugrave; funzionalit&agrave; di jQuery, ma non c'&egrave; niente in jQuery che permetta di emularle. Ad esempio, jQuery non fornisce nessun sistema di ereditariet&agrave;, ma non c'&egrave; problema. Si potrebbe, se si vuole, utilizzare il modulo <em>Class</em> di MooTools in aggiunta a jQuery. C'&egrave; inoltre un <a href="http://code.google.com/p/jquery-inheritance/updates/list">plugin che mette a disposizione l'ereditariet&agrave; in jQuery</a> (non l'ho utilizzato, ma penso offra piu o meno lo stesso tipo di funzionalit&agrave;)
			</p>
	
			<p>Se vediamo questo pezzo di codice jQuery dall'esempio sopra:</p>  
		
<pre class="js">$(document).ready(function() {
    $("a").click(function(event) {
        alert("Grazie per la visita!");
    });
});</pre>
		
			<p>
				e volessimo 'tradurlo' in MooTools, avremmo:  
			</p>
<pre class="js">window.addEvent('domready', function() {
    $$('a').addEvent('click', function(event) {
        alert('Grazie per la visita!');
    });
});</pre>
			<p>
				  Sono molto simili no?          
			</p>
			<p>
			    Prendiamo ora un esempio un po' pi&ugrave; complesso in jQuery:
			</p>

<pre class="js">$(document).ready(function() {
    $("#orderedlist li:last").hover(function() {
        $(this).addClass("green");
    },
    function() {
        $(this).removeClass("green");
    });
});</pre>

			<p>
	    ed in MooTools diverr&agrave;:  
			</p>

<pre class="js">window.addEvent('domready',function() {
    $$('#orderedlist li:last-child').addEvents({
        mouseenter: function() {
            this.addClass('green');
        },
        mouseleave: function() {
            this.removeClass('green');
        }
    });
});</pre>

			<p>
			  Ancora, molto simili. Direi che la versione MooTools e' piu esplicita, ma anche molto verbosa. E' chiaro che leggendo il codice MooTools si intuisca che stiamo aggiungendo due eventi - uno per l'entrata del mouse e l'altro per l'uscita del mouse, mentre la versione jQuery e' piu concisa; il suo metodo <em><a href="http://docs.jquery.com/Events/hover">hover</a></em> accetta due metodi - il primo per l'entrata del cursore del mouse ed il secondo per l'uscita del cursore del mouse. Io personalmente preferisco il codice MooTools in quanto &egrave; pi&ugrave; leggibile, ma e' un'osservazione prettamente personale.
			</p>
			
			<p>
			  Devo dire inoltre che qualche volta jQuery pu&ograve; diventare troppo esoterico per i miei gusti. I metodi non sempre hanno senso per me ed a prima vista li trovo difficili da analizzare. Comunque anche se non sarebbe molto giusto da dire, dato che sono in intimit&agrave; con MooTools, per me leggere MooTools &egrave; pi&ugrave; facile. Una delle cose che apprezzo di MooTools riguarda il fatto che praticamente tutti i nomi dei metodi e delle classi danno il vero nome alle cose. I metodi sono quasi sempre verbi e lasciano pochi dubbi riguardo quello che fanno. Ogni linguaggio di programmazione richiede una ricerca nella documentazione per la sintassi quando si scrive il codice - Non parlo di questo. Sto dicendo solamente che trovo le API di MooTools piu coerenti e consistenti.
			</p>
			
			<a name="yourway"></a>
			<h2>MooTools Fa Ci&ograve; Che Vuoi Come Vuoi</h2>
			
			<p>
			  E se ti piace la sintassi jQuery? Un modo per illustrare il potere di MooTools e' mostrare quanto facile sia cambiare il codice in modo che si addica ai propri gusti. Se avessimo voluto implementare il metodo <em>hover</em> da jQuery a MooTools, avremmo potuto facilmente fare cos&igrave;:</p>
			
<pre class="js">Element.implement({
    hover : function(enter,leave){
       return this.addEvents({ mouseenter : enter, mouseleave : leave });
    }
});

//e quindi lo si potra' usare esattamente come nella versione jQuery:
$$('#orderlist li:last').hover(function(){
   this.addClass('green');
},
function(){
   this.removeClass('green');
});
</pre>

		<p>
		  Ci sono addirittura plugins MooTools che fanno questo; <a href="http://github.com/cheeaun/mooj/tree/master">forniscono una sintassi jQuery per MooTools</a>. Il focalizzarsi di MooTools riguardo l'estensibilit&agrave; significa che si pu&ograve; implementare praticamente qualsiasi cosa si voglia. Questo &egrave; qualcosa che jQuery non pu&ograve; fare. MooTools puo' simulare jQuery volendo, ma jQuery non puo' mimare MooTools. Se si vogliono scrivere classi oppure estendere i prototipi nativi o fare qualcosa che MooTools puo' fare, avendo adottato jQuery bisogner&agrave; farlo a mano.
		  </p>
		
			<a name="chaining"></a>
			<h2>La Concatenazione Come Design Pattern</h2> 
		
			<p>
			    Facciamo un'altro di questi esperimenti. Qui sotto c'e' del codice jQuery (dal tutorial ufficiale):
			</p>

<pre class="js">$(document).ready(function() {
    $('#faq').find('dd').hide().end().find('dt').click(function() {
        $(this).next().slideToggle();
    });
});</pre>

			<p>
			  
			  Questo &egrave; un esempio di sintassi che personalmente non mi alletta. Guardando il codice qui sopra, non sono molto sicuro di quello che stia facendo. In particolare sarei curioso di capire cosa fa <em>.end</em> e come <em>.find</em>, che lo segue, sia in relazione a quello che fa <em>.end</em>? Ora, guardando la documentazione jQuery si capisce benissimo cosa fa <em>.end </em>(resetta il valore del selettore originale, in questo caso #faq). Ma a me sembra strano. Quando lavoro con jQuery, spesso mi ritrovo ad essere insicuro riguardo cosa faccia un particolare metodo. Ovviamente ci&ograve; riguarda solo me dato che jQuery viene utilizzato da tantissime persone (che sono contente di usarlo), quindi anche questa &egrave; una preferenza personale.
			</p>
			<p>
				      Vediamo la logica spiegata sopra in MooTools:  
			</p>

<pre class="js">window.addEvent('domready', function() {
    var faq = $('faq');
    faq.getElements('dd').hide();
    faq.getElements('dt').addEvent('click', function() {
        this.getNext().slide('toggle');
    });
});
</pre>


			<p>
			  Ancora, il codice scritto con MooTools &egrave; pi&ugrave; verboso, ma anche pi&ugrave; esplicito. Si nota pure che il design pattern in questo caso riguarda salvare l'elemento #faq in una variabile (dove jQuery usa il metodo <em>.end</em> per ritornarla). Faccio notare che &egrave; possibile anche in MooTools scrivere codice concatenato. Ad Esempio:
			</p>
<pre class="js">item.getElements('input[type=checkbox]')
	.filter(function(box) {
		return box.checked != checked;
	})
	.set('checked', checked)
	.getParent()[(checked) ? 'addClass' : 'removeClass']('checked')
	.fireEvent((checked) ? 'check' : 'uncheck');</pre>
			
			<p>
			  Comunque, scrivere codice come questo - molta logica dentro domready - con entrambi i frameworks, direi che &egrave; una brutta abitudine. &Egrave;' molto meglio incapsulare la logica in moduli riusabili.
			</p>
			
			<a name="reuse"></a>
			<h2>Riutilizzo del codice con jQuery</h2>
			
			<p>
			  &Egrave; molto allettante quando si lavora ad un progetto web scrivere del codice in questo modo. Basta soltanto aggiungere un po' di logica nella pagina per selezionare gli elementi del DOM e "settarli" nascondendone alcuni, alterandone degli altri, ed aggiungendo degli event listeners per i click ed i mouseover. Sviluppare il codice in questo modo &egrave; molto efficiente, molto veloce. Il  problema che nasce scrivendo tutta la propria logica all'interno della funzione associata alla domready riguarda il fatto che molti pezzi di codice fanno le stesse cose ma in posti differenti. Se prendiamo il pattern FAQ descritto sopra potremmo applicare la stessa logica in qualche altra parte in una pagina differente con qualsiasi lista di termini e definizioni. Si dovr&agrave; ripetere la stessa logica ogni volta che si trover&agrave; questo pattern?
			</p>
			<p>
			    Un metodo semplice per rendere il codice riusabile si ottiene "impacchettando" la logica in una funzione e passandogli degli argomenti. Qui di seguito ecco come si potrebbe fare in jQuery:
			</p>

<pre class="js">function faq(container, terms, definitions) {
    $(container).find(terms).hide().end().find(definitions).click(function() {
        $(this).next().slideToggle();
    });
};
$(document).ready(function() {
    faq('#faq', 'dd', 'dt');
});</pre>

			<p>
			  Questo metodo &egrave; migliore per due ragioni importantissime:
			</p>
			<ol>
				<li>
				  Se in futuro ci sar&agrave; bisogno di cambiare il modo in cui queste liste funzionano (ad esempio se si volesse tener traccia dei click in un log web oppure se si volessero recuperare le definizioni tramite ajax) potremmo solamente cambiare il nostro metodo <i>faq</i> invece che andare a modificare svariate copie ovunque. Di questo ne tengo una piccola traccia nella mia applicazione. Tenendo appunto traccia dei punti dove la mia applicazione tocca il codice generico, sar&agrave; pi&ugrave; facile sistemare i bugs, aggiornare i frameworks, aggiungere features, o alterare funzionalit&agrave;
				</li>
				<li>
				  La seconda: c'&egrave; meno codice. Riusando lo stesso metodo pi&ugrave; volte, non bisogner&agrave; ripetersi e questo &egrave; un valore aggiunto in ogni ambiente di programmazione. Rende inoltre il codice che i visitatori devono scaricare meno pesante.
				</li>
			</ol>  
			<p>
			  jQuery attualmente ha un metodo un po' pi&ugrave; rifinito per scrivere "widget" riusabili come questi. Piuttosto che incoraggiare a mettere tutto dentro funzioni come nell'esempio qui sopra (che &egrave; piuttosto rudimentale), incoraggia a scrivere plugins jQuery. In questo modo:

<pre class="js">jQuery.fn.faq = function(options) {
    var settings = jQuery.extend({
        terms: 'dt',
        definitions: 'dd'
    }, options); 
	  //"this" e' il contesto corrente; in questo caso, gli elementi ai quali vogliamo applicare un layout faq
    $(this).find(settings.terms).hide().end().find(settings.definitions).click(function() {
        $(this).next().slideToggle();
    });
    return this;
};</pre>

			</p>
			    che di conseguenza si potrebbe usare cos&igrave;:
			</p>
	<pre class="js">$('#faq').faq();</pre>

			<p>
			  Guardando all'esempio qui sopra, non c'&egrave; molta differenza tra dichiarare la nostra funzione <i>faq</i> in questo modo e dichiararla come una funzione vera e propria. Ammesso che, non &egrave; nel namespace globale, ma potremmo aggiungerlo facilmente. Rendendolo plugin jQuery potremmo quindi concatenarlo ad altri suoi metodi. L'altro beneficio riguarda il "this" che all'interno della nostra funzione &egrave; il contesto corrente dell'elemento nella concatenazione jQuery in quel momento. Utilizzando questo pattern per i plugins si potr&agrave; essere in grado di renderli parte integrante di jQuery, ma a parte quello, un plugin e' praticamente una singola funzione che prende il contesto corrente jQuery, ci fa qualcosa, e poi ritorna il contesto per il prossimo elemento nella catena. Non &egrave; molto complesso il discorso, ed infatti questo rende molto semplice per chiunque scrivere plugins jQuery - sono solamente delle singole funzioni.
			</p>

			<p>
			  
			  Si noti che &egrave; possibile scrivere plugins jQuery pi&ugrave; complessi con i metodi e gli stati. Questo tipo di pattern &egrave; supportato dal sistema di plugins jQuery UI e non usa lo stesso meccanismo del plugin di base (come il nostro esempio delle faq). Invece, si attacca un oggetto con metodi e propriet&agrave; all'oggetto jQuery (i.e. <em>$.ui.tabs</em>). C'&egrave; un modo semplice per invocare questo oggetto (<em>$(selector).tabs()</em>) cosicch&egrave; si possa continuare a concatenare come nel plugin faq. Dato che non ritorna una referenza all'oggetto tabs creato per gli elmenti nel nostro selettore, si &egrave; forzati a chiamare ancora il selettore per invocarci metodi. Invece di chiamare <em>myTabInstance.add(url, label, index)</em> bisogner&agrave; eseguire un'altra volta il selettore e chiamare la funzione (come stringa): <em>$(selector).tabs('add',url,label, index)</em>. Questo significa che si stanno valutando i selettori 2 volte (a meno che non si salvino in una variabile da qualche parte), e che non si ha mai un puntatore al metodo "add" che renda possibile un <em>bind</em> oppure un <em>delay</em>. Questo post comunque &egrave; focalizzato sui core di MooTools e jQuery, e mentre il sistema jQuery UI fornisce questa funzionalit&agrave;, non &egrave; qualcosa che &egrave; disponibile in jQuery di default.
			</p>

			<a name="classes"></a>
			<h2>Riutilizzo del Codice con MooTools</h2>

			<p>
			  In MooTools quando si vuol definire un pattern, si tende o ad usare <em><a href="http://mootools.net/docs/core/Class/Class">Class</a></em> oppure si implementa un metodo in un oggetto nativo (su <em>String</em>, ad esempio).
			</p>
		
			<p>
			  Piuttosto che dare un linguaggio completamente differente dallo stile nativo di JavaScript, MooTools cerca di stare in mezzo alla definizione di una sintassi personalizzata e di estendere i design patterns propri di JavaScript. Uno dei modi in cui lo fa &egrave; tramite l'estensione dei prototipi degli oggetti nativi nel linguaggio e nel DOM. Questo significa che se ci fosse bisogno di un metodo che fa la trim di una stringa, MooTools incoraggia ad aggiungere quel metodo nell'oggetto String (notare che <em><a href="http://mootools.net/docs/core/Native/String#String:trim">String.trim</a></em> &egrave; gi&agrave; presente in MooTools; non serve aggiungerlo a mano):
			</p>

<pre class="js">String.implement({
    trim: function() {
        return this.replace(/^\s+|\s+$/g, '');
    }
});</pre>

			<p>
			  Questo significa che si pu&ograve; solamente eseguire <i>" non piu spazi alla fine! ".trim()</i> ed ottenere <i>"non piu spazi alla fine!"</i>. Alcuni direbbero che implementare propriet&agrave; direttamente nei prototipi nativi &egrave; inappropriato. &Egrave; questa la ragione per la quale MooTools e <a href="http://www.prototypejs.org/">Prototype.js</a> non possono essere usati assieme - i framework che manipolano i prototipi dei tipi nativi non possono essere usati con altri frameworks che fanno lo stesso. Se si definisce <i>String.prototype.foo()</i> ed un'altra libreria nella stessa pagina definisce lo stesso, 'vince' il metodo che viene definito per ultimo. In un certo modo, si pu&ograve; dire che &egrave; lo stesso problema che si incontra con il namespace globale <em>window</em>. Comunque &egrave; così che funziona JavaScript. &Egrave; in questo modo che <a href="https://developer.mozilla.org/En/New_in_JavaScript_1.8">JavaScript 1.8</a> ha aggiunto moltissime features. Le aggiunge direttamente ai prototipi.
			</p>
			<p>
			  Gli sviluppatori MooTools hanno lavorato in modo che il framework sia semplice da estendere e da utilizzare nella sua totalit&agrave;, senza ricorrere ad altri frameworks. Inoltre sarebbe scortese domandare agli utenti di scaricare due frameworks diversi. La sola ragione valida per includere due frameworks riguarda il voler usufruire di plugins per entrambi, e nella mente degli autori di MooTools (io compreso), se si vuole un plugin che non &egrave; disponibile per il framework adottato, sarebbe pi&ugrave; appropriato spendere del tempo per fare il porting per il proprio ambiente piuttosto che far scaricare agli utenti un altro framework.
			</p>
			<p>
			  Una volta che si &egrave; capito come funziona JavaScript e si e' realizzato il potere dell'estensione dei tipi nativi, si scoprir&agrave; un nuovo metodo di programmazione. Si potranno scrivere plugins che alterano Elements, oppure Dates, o Functions. Mentre qualcuno direbbe che aggiungere metodi ai tipi nativi &egrave; 'sporco', io dico che &egrave; proprio questa la feature principale di JavaScript. &Egrave; una sua caratteristica architetturale. Aggiungendo metodi ai tipi nativi il codice risulter&agrave; conciso e compartimentalizzato. Anche jQuery utilizza questo metodo, ma limita il prototyping al solo oggetto jQuery (alias <em>$</em>).
			</p>
			
			<p>
			  Mentre si possono concatenare chiamate a metodi sull'oggetto jQuery, negli altri tipi di oggetti non si potr&agrave; fare una concatenazione. Ad esempio, se si vuole in jQuery fare il trim di una stringa e poi iterare ogni riga, si dovrebbe scrivere:
			</p>

			<pre class="js">$.each( $.trim( $('span.something').html() ).split("\n"), function(i, line){alert(line);});</pre>

			<p>In MooTools invece, dato che si modificano i prototipi, si pu&ograve; fare questo:</p>

			<pre class="js">$('span.something').get('html').trim().split("\n").each(function(line){alert(line);});</pre>

			<p>
			  Solamente guardando a questo esempio risulta estremamente chiara la potenza dell'estensione dei prototipi. Il concatenamento negli elementi del DOM non &egrave; il solo posto dove risulta utile. MooTools fa si che si possano concatenare chiamate a metodi su tutti gli oggetti, incluse chiamate ad un metodo su pi&ugrave; elementi in una singola volta.
			</p>
			
			<p>
			  La chiave qui, ed &egrave; il cuore del framework MooTools, &egrave; il guidare a programmare ci&ograve; che si vuole. Se una funzionalit&agrave; non &egrave; presente nel core, quest'ultimo lo si pu&ograve; estendere aggiungendola. L'obiettivo del core non &egrave; provvedere ad ogni singola funzionalit&agrave; possibile ed immaginabile, ma &egrave; mettere a disposizione gli strumenti che fanno scrivere ci&ograve; che si vuole. Una grossa parte riguarda la facilit&agrave; con la quale si possono estendere i tipi nativi, traendo vantaggio dall'ereditariet&agrave; prototipale. Si possono fare tutte queste cose in JavaScript nativo, ma MooTools rende il tutto pi&ugrave; semplice e pi&ugrave; piacevole.				
			</p>
			
			
			<a name="mooinheritance"></a>
			<h3>MooTools and Inheritance</h3>
		
			<p>
				Despite its name, the MooTools <em>Class</em> function is not really a class nor does it create them. It has design patterns that might remind you of classes in a more traditional programming language, but really <em>Class</em> is all about objects and prototypal inheritance. (Unfortunately, using words like "class" are the most convenient way to describe these things, so for the purposes of this article, when I refer to "classes" I'm referring to functions that return objects - which I'll call "instances" - that inherit from a prototype.)
			</p>
			<p>
				To make a class, you pass an object to the <em>Class</em> constructor like this:
			</p>
		
<pre class="js">var Human = new Class({
    initialize: function(name, age) {
        this.name = name;
        this.age = age;
    },
    isAlive: true,
    energy: 1,
    eat: function() {
        this.energy = this.energy + 1; //same as this.energy++
    }
});</pre>
		
			<p>
				You pass <em>Class</em> an object (above, we pass an object with members like "isAlive" and "eat") and this object becomes the prototype of every instance of that class. To create an instance, you call it like this:
			</p>
<pre class="js">var bob = new Human("bob", 20); //bob's name is "bob" and he's 20 years old.</pre>
			<p>
				Now we have an instance of <em>Human</em>. <em>bob</em> has the properties of the object we defined when we created our <em>Human</em> class. But the important thing is that <em>bob</em> has these properties through inheritance. When we reference <i>bob.eat</i>, <i>bob</i> doesn't really have this property. JavaScript looks at <i>bob</i> and he doesn't have an <i>eat</i> method, so it looks up the inheritance chain and finds it on the object we passed when we created the <em>Human</em> class. This is true for <i>energy</i>, too. At first glance this looks potentially bad; we don't want all the humans we create to gain energy every time that <i>bob</i> eats. The important thing to recognize is that the first time we assign a value to <i>bob</i>'s energy, we assign him his own value and we no longer look at the prototype for it. So the first time <i>bob</i> eats, he gets his own definition for <em>energy</em> (set to 2).
			</p>
			<pre class="js">bob.eat(); //bob.energy == 2</pre>
			<p>
				Note that <em>bob</em>'s name and age are unique to him; these are assigned to him when the class is initialized in the <i>initialize</i> method.
			</p>
			<p>
				This whole pattern may seem a little odd to you, but the value here is that we can define functionality for a pattern and create instances of that pattern every time we need it. Each instance maintains its own state. So if we create another instance each one is independent of the other, but inherits from the same base pattern:
			</p>
		
<pre class="js">var Alice = new Human();
//alice.energy == 1
//bob.energy == 2</pre>
		
			<p>
				Where things get really interesting is when we want to augment this behavior.
			</p>
			
			<a name="extension"></a>
			<h3>Extending and Implementing Classes</h3>
		
			<p>
				Let's revisit our jQuery <i>faq</i> plug-in. What would happen if we wanted to add more functionality to that plug-in. What if we wanted to make an ajax version that fetched the answers to the questions from the server? Let's imagine that the <i>faq</i> plug-in was authored by someone else and we want to add more to it without altering it in any way (we don't want to fork it).
			</p>
			<p>
				Our only real choices are to either duplicate the <em>faq</em> plug-in's logic entirely (remember, it's a single function), essentially forking it, or we can invoke it and then add more logic to it. Given a choice, the latter seems to save us the most trouble. It would look something like this:
			</p>
<pre class="js">jQuery.fn.ajaxFaq = function(options) {
    var settings = jQuery.extend({ 
		//some ajax specific options like the url to request terms from
        url: '/getfaq.php'
        definitions: 'dd'
    }, options); 
	//"this" is the current context; in this case, the elements we want to turn into faq layouts
    $(this).find(settings.definitions).click(function() {
        $(this).load(.....); //the logic to load the content from the term
    });
    this.faq(); //call our original faq plug-in
});</pre>
			<p>
				This has some down sides. First of all, our <em>faq</em> class is going to repeat our selector for the definitions, which might be expensive; there's no way to store the retrieved definitions and pass it on for the second time they are needed. Secondly, we can't add our ajax logic into the middle of the <em>faq</em> plug-in's own logic for displaying the definition. The original plug-in called <em>slideToggle</em> which expands the definition using an effect. This is problematic because this effect is going to go off before our ajax finishes loading. There's no real solution here unless we just duplicate the entire <em>faq</em> plug-in.
			</p>
			<p>
				Now let's consider our MooTools <em>Human</em> class. It has properties like <em>isAlive</em> and <em>energy</em> and it has a method called <em>eat</em>. What if we wanted to make a new version of <em>Human</em> that had additional properties? With MooTools, we extend the class:
			</p>
<pre class="js">var Ninja = new Class({
    Extends: Human,
    initialize: function(name, age, side) {
        this.side = side;
        this.parent(name, age);
    },
    energy: 100,
    attack: function(target) {
        this.energy = this.energy - 5;
        target.isAlive = false;
    }
});</pre>
			<p>
				You can see that we've added a lot of functionality here into a subclass. This subclass has all these properties that are unique to <em>Ninjas</em>. <em>Ninjas</em> start off with an initial <em>energy</em> value of 100. <em>Ninjas</em> get a <em>side</em>. They also get an <em>attack</em> method that lets them kill other <em>Humans</em>, but it costs the <em>Ninja</em> energy.
			</p>

<pre class="js">var bob = new Human('Bob', 25);
var blackNinja = new Ninja('Nin Tendo', 'unknown', 'evil');
//blackNinja.isAlive = true
//blackNinja.name = 'Nin Tendo'
blackNinja.attack(bob);
//bob never had a chance</pre>

			<p>
				Picking this apart a bit, there are some interesting things to consider here. Note that we have an <em>initialize</em> method in the <em>Ninja</em> class. This would appear to overwrite the <em>initialize</em> method in the <em>Human</em> class, but we can still access it by calling <em>this.parent</em>, passing along the arguments that the parent class's <em>initialize</em> expects. Further, we can control when our logic occurs; before or after the call to the parent. We can assign new values to properties (like the <em>energy</em> value) and we can define new functionality. Imagine if we could do this with our <em>faq</em> plug-in for jQuery. We could load our ajax and THEN slide open the value.
			</p>
			<p>
				MooTools has another pattern called a Mixin. Unlike the parent to
				child relationship that is defined by extending one class into a
				subclass, you can also define classes that are mixed into other
				classes to imbue them with their properties. Here's an example:
			</p>

<pre class="js">var Warrior = new Class({
    energy: 100,
    kills: 0,
    attack: function(target) {
        target.isAlive = false;
        this.energy = this.energy - 5;
        this.kills++;
    }
});</pre>

			<p>
				Here we've broken the qualities that make a <em>Ninja</em> different from a <em>Human</em> and put them in a class of their own. This lets us reuse this code outside of <em>Ninja</em>. We could then imbue our <em>Ninja</em> class with the qualities of a warrior like so:
			</p>

<pre class="js">var Ninja = new Class({
    Extends: Human,
    Implements: Warrior, //can be an array if you want to implement more than one
    initialize: function(name, age, side) {
        this.side = side;
        this.parent(name, age);
    }
});</pre>
		
			<p>
				<em>Ninja</em> still works as it did before, but <em>Warrior</em> is at our disposal to reuse:
			</p>

<pre class="js">var Samurai = new Class({
  Extends: Human,
  Implements: Warrior,
  side: 'good'
});</pre>

			<p>
				Now we have a <em>Samurai</em> class and a <em>Ninja</em> class. But look at how little code both <em>Ninja</em> and <em>Samurai</em> took to define. Both of them are similar in that they are humans with warrior qualities, but they are different in that samurais are always, always good, while ninjas have shifting allegiances. By spending the time to write a <em>Human</em> class and a <em>Warrior</em> class, we're able to have three different classes with no repetition of code while maintaining a very granular level of control over when methods are called and how they relate to each other. Each instance we create has its own state and the code itself is very legible.
			</p>
			
			<p>
				Now that you have an overview of how classes work in MooTools, let's look at our <em>faq</em> class that we wrote in jQuery and write it as we would in MooTools and then extend it to add Ajax to it just as we did with jQuery.				
			</p>
<pre class="js">
var FAQ = new Class({
	//Options is another class provided by MooTools
	Implements: Options,
	//these are the default options
	options: {
		terms: 'dt',
		definitions: 'dd'
	},
	initialize: function(container, options) {
		//we store a reference to our container
		this.container = $(container);
		//setOptions is a method provided by the Options mixin
		//it merges the options passed in with the defaults
		this.setOptions(options);
		//we store the terms and definitions
		this.terms = this.container.getElements(this.options.terms);
		this.definitions = this.container.getElements(this.options.definitions);
		//we call our attach method
		//by breaking this into its own method
		//it makes our class easier to extend
		this.attach();
	},
	attach: function(){
		//loop through the terms
		this.terms.each(function(term, index) {
			//add a click event to each one
			term.addEvent('click', function(){
				//that calls our toggle method for
				//the current index
				this.toggle(index);
			}, this);
		}, this);
	},
	toggle: function(index){
		//toggle open the definition for the given index
		this.definitions[index].slide('toggle');
	}
});
</pre>

			<p>
				Woah. That's a lot of code. Even if we remove all the comments it's still two dozen lines long. I already illustrated above that we could build this plug-in with roughly the same amount of code as the jQuery version. So why is this one so much longer? Well, we've made it much more flexible. To use the class, we just call the constructor, like this:
			</p>

<pre class="js">var myFAQ = new FAQ(myContainer);
//and now we can call methods on it if we want:
myFAQ.toggle(2); //toggle the 3rd element
</pre>

			<p>
				We can access methods and properties of the instance. But what about our ajax functionality? The problem with our ajax extension to the jQuery version was that we couldn't delay the opening of the definition until after it loaded. We don't have that problem with our MooTools version:
				
			</p>

<pre class="js">FAQ.Ajax = new Class({
	//this class inherits the properties of FAQ
	Extends: FAQ,
	//it also gets a new option in addition to the other defaults
	//this one for url, that we're going to append the index of the
	//term to; in reality we might make this more robust, but for
	//this example it serves the purpose
	options: {
		url: null;
	},
	//we're going to cache the results, so if a section is opened
	//twice, we won't hit the server for the data
	indexesLoaded: [],
	toggle: function(index){
		//if we've already loaded the definition
		if (this.indexesLoaded[index]) {
			//just call the previous version of toggle
			this.parent(index);
		} else {
			//otherwise, request the data from the server
			new Request.HTML({
				update: this.definitions[index],
				url: this.options.url + index,
				//and when the data is loaded, expand the definition
				onComplete: function(){
					this.indexesLoaded[index] = true;
					this.definitions[index].slide('toggle');
				}.bind(this)
			}).send();
		}
	}
});
</pre>

			<p>
				Now we have a version of our <em>FAQ</em> class that allows us to get the definitions from the server. Note that we were able to integrate the new logic in a way that doesn't expand the definition until <em>after</em> the content comes back from the server (which we couldn't do with the jQuery version). Also note that we really only had to describe the new functionality (the ajax) and little else. This extensibility makes it possible for you to create families of plug-ins that offer different shades of functionality. It also means that you can use someone else's plug-in and alter just the bits that you to be want different if you need to (without forking it). This helps explain why, for any given design pattern - a date picker, a tab interface, etc, that you typically only find a few plug-ins for MooTools. Most of the plug-ins you get either solve your problem or, if not, you can just extend them to add the things you need.
				
			</p>
			
			<p>
				As I illustrated earlier, it's possible to write complex jQuery widgets with methods and state. Most of the code you write when doing this is vanilla JavaScript when you need to express logic that isn't related to the DOM. But jQuery's model doesn't offer a system for extending these instances into subclasses. Nor does it help you with mixins that can be reused easily. Finally, jQuery's plugins are always attached to DOM elements. If you wanted to write a class that, say, processed URLs, there's no stateful system for such a thing unless you write it yourself.
			</p>
			
			<a name="conclusion"></a>
			<h2>Decision Time</h2>
		
			<p>
				jQuery focuses on expressiveness, quick and easy coding, and the DOM while MooTools focuses on extension, inheritance, legibility, reuse, and maintainability. If you put those two things on opposite sides of a scale, the jQuery side translates into something with which it's easy to get started and see quick results but (in my experience) can turn into code that's harder to reuse and maintain (but really that's up to you; it's not jQuery's problem, per se), while the MooTools side takes longer to learn and requires you to write more code upfront before you see results, but afterwards is more reusable and more maintainable.
			</p>
			<p>
				Further, the MooTools core does not contain every feature you can imagine and neither does the jQuery core. Both frameworks keep their cores rather lean, leaving it to you and others to write plug-ins and extensions. Their job is not to give you every feature you could want but to give you the tools so that you can implement anything you can imagine. This is the power of JavaScript, and of JavaScript frameworks in general, and both frameworks excel at it. MooTools takes a more holistic approach and gives you tools to write anything you can imagine beyond the scope of the DOM, but pays the price by having a steeper learning curve. MooTools' extensible and holistic approach gives you a superset of jQuery's features, but jQuery's focus on a slick DOM API doesn't preclude you from using the native inheritance methods of JavaScript or from using a class system like MooTools if you want it.
			</p>
			<p>
				This is why I say that both frameworks are excellent choices. My effort here has been to highlight the differences in philosophies between the two codebases and highlight their advantages and disadvantages. I doubt I've been successful in keeping my preference for MooTools completely in check, but hopefully this has been helpful. Regardless of which framework you choose to work with, you now know a lot more about both, hopefully. If you have the luxury of time, I strongly recommend implementing a site with each. Then write your own review of them both and maybe your perspective will highlight some things I missed.
			</p>
			<p>A history of this document <a href="http://github.com/anutron/jquery-vs-mootools/tree/master">can be viewed on github</a>.</p>
			<p>
			<script type="text/javascript" src="http://w.sharethis.com/button/sharethis.js#publisher=c327065b-efa0-4e12-afbc-5717f5cf62f9&amp;type=website&amp;post_services=facebook%2Cdigg%2Cdelicious%2Ctwitter%2Creddit%2Cfriendfeed%2Cmyspace%2Cybuzz%2Cstumbleupon%2Ctechnorati%2Cmixx%2Cblogger%2Cwordpress%2Ctypepad%2Cgoogle_bmarks%2Cwindows_live%2Cfark%2Cbus_exchange%2Cpropeller%2Cnewsvine%2Clinkedin"></script>
			</p>
			<hr/>
			<p class="about">
				About me: I am a <a href="http://www.mootools.net">MooTools</a> contributor and I blog about JavaScript and other things on my site <a href="http://www.clientcide.com">Clientcide</a> as well as release <a href="http://www.clientcide.com/js">numerous plug-ins for MooTools</a>. I am the author of <a href="http://www.amazon.com/gp/product/1430209836?ie=UTF8&tag=clientside-20&link_code=as3&camp=211189&creative=373489&creativeASIN=1430209836">MooTools Essentials</a> as well as the <a href="http://www.mootorial.com">MooTools online tutorial</a>. I work at a company in the SF Bay Area called <a href="http://www.cloudera.com">Cloudera</a>. <a href="http://www.clientcide.com/shout-out">I can be contacted thusly</a>.
			</p>
			
			<a name="discussion"></a>
			<hr/>
			<p class="about" style="color: #700"><strong>A note on comments here</strong>: These comments are moderated. No comments will show up until they are approved. Comments that are not productive (i.e. inflammatory, rude, etc) will not be approved. Similarly, "fan" comments won't be approved either - i.e. no "FrameworkX Rulez! It's better than FrameworkY for realz!" are not constructive comments.
			</p>
			<div id="disqus_thread"></div>
			<script>
				var disqus_url = "http://jqueryvsmootools.com/";
			</script>
			<script type="text/javascript" src="http://disqus.com/forums/jqueryvsmootools/embed.js"></script>
		</div>
		<script type="text/javascript">
		var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
		document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
		</script>
		<script type="text/javascript">
		try {
		var pageTracker = _gat._getTracker("UA-539314-11");
		pageTracker._trackPageview();
		} catch(err) {}</script>
		
		<script type="text/javascript">
		//<![CDATA[
		(function() {
				var links = document.getElementsByTagName('a');
				var query = '?';
				for(var i = 0; i < links.length; i++) {
					if(links[i].href.indexOf('#disqus_thread') >= 0) {
						query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
					}
				}
				document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/jqueryvsmootools/get_num_replies.js' + query + '"></' + 'script>');
			})();
		//]]>
		</script>
		
	</body>
</html>